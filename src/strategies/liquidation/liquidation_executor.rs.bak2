/// ì²­ì‚° ì‹¤í–‰ ëª¨ë“ˆ
///
/// ì—­í• : ì²­ì‚° íŠ¸ëœì­ì…˜ ìƒì„± ë° ë¸Œë¡œë“œìºìŠ¤íŠ¸
/// - í”„ë¡œí† ì½œë³„ ì²­ì‚° íŠ¸ëœì­ì…˜ ìƒì„± (Aave, Compound, Maker)
/// - MEV-Boostë¥¼ í†µí•œ í”„ë¼ì´ë¹— íŠ¸ëœì­ì…˜ ì œì¶œ
/// - í¼ë¸”ë¦­ ë©¤í’€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
/// - ë™ì  íŒ ê³„ì‚°

use std::sync::Arc;
use anyhow::Result;
use alloy::primitives::{Address, U256};
use tracing::{info, debug, warn};
use rust_decimal::prelude::ToPrimitive;
use chrono::Utc;

use crate::types::{Transaction, Opportunity};
use crate::blockchain::BlockchainClient;
use crate::config::Config;
use crate::strategies::liquidation::types::{PrivateSubmissionResult, ExecutionMode};

#[derive(Debug, Clone)]
pub enum CompetitionLevel {
    Low,
    Medium,
    High,
    VeryHigh,
}

#[derive(Debug, Clone)]
pub struct GasAnalysis {
    pub current_gas_price: f64,
    pub is_high_gas: bool,
    pub trend: GasTrend,
    pub network_congestion: f64,
}

#[derive(Debug, Clone)]
pub enum GasTrend {
    Rising,
    Falling,
    Stable,
}

pub struct LiquidationExecutor {
    config: Arc<Config>,
    blockchain_client: Arc<BlockchainClient>,
    gas_multiplier: f64,
    max_gas_price: U256,
}

impl LiquidationExecutor {
    pub fn new(
        config: Arc<Config>,
        blockchain_client: Arc<BlockchainClient>,
        gas_multiplier: f64,
        max_gas_price: U256,
    ) -> Self {
        Self {
            config,
            blockchain_client,
            gas_multiplier,
            max_gas_price,
        }
    }

    /// ì‹¤í–‰ ëª¨ë“œë¥¼ ì„ íƒí•´ì„œ ì²­ì‚° ì‹¤í–‰
    pub async fn execute_liquidation(&self, opportunity: &Opportunity, mode: ExecutionMode) -> Result<bool> {
        info!("ğŸ’¸ ì²­ì‚° ì‹¤í–‰ ì‹œì‘ - ëª¨ë“œ: {}", mode);

        let tx = self.create_liquidation_transaction(opportunity).await?;

        match mode {
            ExecutionMode::Flashbot => {
                info!("ğŸ”’ Flashbot í”„ë¼ì´ë¹— ëª¨ë“œë¡œ ì‹¤í–‰");
                self.execute_via_flashbot(&tx, opportunity).await
            },
            ExecutionMode::Public => {
                info!("ğŸŒ Public ë©¤í’€ ëª¨ë“œë¡œ ì‹¤í–‰");
                self.execute_via_public_mempool(&tx).await
            },
            ExecutionMode::Hybrid => {
                info!("âš¡ Hybrid ëª¨ë“œë¡œ ì‹¤í–‰ (Flashbot ìš°ì„ , ì‹¤íŒ¨ ì‹œ Public)");

                // Flashbot ë¨¼ì € ì‹œë„
                match self.execute_via_flashbot(&tx, opportunity).await {
                    Ok(true) => {
                        info!("âœ… Flashbotìœ¼ë¡œ ì„±ê³µ");
                        Ok(true)
                    },
                    Ok(false) | Err(_) => {
                        warn!("âš ï¸ Flashbot ì‹¤íŒ¨, Public ë©¤í’€ë¡œ í´ë°±");
                        self.execute_via_public_mempool(&tx).await
                    }
                }
            }
        }
    }

    /// Flashbotì„ í†µí•œ í”„ë¼ì´ë¹— ì‹¤í–‰
    async fn execute_via_flashbot(&self, tx: &Transaction, opportunity: &Opportunity) -> Result<bool> {
        info!("ğŸ” Flashbotì„ í†µí•œ í”„ë¼ì´ë¹— íŠ¸ëœì­ì…˜ ì œì¶œ");

        let tip = self.calculate_dynamic_tip(opportunity).await?;

        let result = self.submit_private(tx.clone(), tip).await?;

        if result.success {
            info!("âœ… Flashbot ì œì¶œ ì„±ê³µ: bundle_hash={:?}", result.bundle_hash);
            Ok(true)
        } else {
            warn!("âŒ Flashbot ì œì¶œ ì‹¤íŒ¨: {:?}", result.error);
            Ok(false)
        }
    }

    /// Public ë©¤í’€ì„ í†µí•œ ì‹¤í–‰
    async fn execute_via_public_mempool(&self, tx: &Transaction) -> Result<bool> {
        info!("ğŸŒ Public ë©¤í’€ë¡œ íŠ¸ëœì­ì…˜ ë¸Œë¡œë“œìºìŠ¤íŠ¸");

        let success = self.broadcast_public(tx.clone()).await?;

        if success {
            info!("âœ… Public ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì„±ê³µ");
            Ok(true)
        } else {
            warn!("âŒ Public ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì‹¤íŒ¨");
            Ok(false)
        }
    }

    /// MEV-Liteë¥¼ ì´ìš©í•œ ì²­ì‚° ì‹¤í–‰ (ë ˆê±°ì‹œ)
    pub async fn execute_with_mev_lite(&self, opportunity: &Opportunity) -> Result<bool> {
        info!("ğŸ’¸ MEV-lite ì²­ì‚° ì‹¤í–‰ ì‹œì‘");

        // 1) ì²­ì‚° íŠ¸ëœì­ì…˜ ìƒì„±
        let liquidation_tx = self.create_liquidation_transaction(opportunity).await?;

        // 2) ë™ì  íŒ ê³„ì‚° (ì˜ˆìƒ ìˆ˜ìµì˜ ì¼ë¶€)
        let tip_amount = self.calculate_dynamic_tip(opportunity).await?;

        // 3) í”„ë¼ì´ë¹— ì œì¶œ (ë©€í‹° ë¦´ë ˆì´)
        let result = self.submit_private(liquidation_tx.clone(), tip_amount).await?;

        if result.success {
            info!("âœ… í”„ë¼ì´ë¹— ì²­ì‚° ì œì¶œ ì„±ê³µ (ë¦´ë ˆì´: {:?})", result.bundle_hash);
        } else {
            warn!("âŒ í”„ë¼ì´ë¹— ì²­ì‚° ì‹¤íŒ¨, í¼ë¸”ë¦­ í´ë°± ì‹œë„");
            // 4) í¼ë¸”ë¦­ í´ë°±
            let fallback_result = self.broadcast_public(liquidation_tx).await?;
            return Ok(fallback_result);
        }

        Ok(result.success)
    }

    /// ì²­ì‚° íŠ¸ëœì­ì…˜ ìƒì„±
    pub async fn create_liquidation_transaction(&self, opportunity: &Opportunity) -> Result<Transaction> {
        info!("ğŸ”¨ ì²­ì‚° íŠ¸ëœì­ì…˜ ìƒì„± ì¤‘...");

        // Opportunityì—ì„œ ì‹¤ì œ ì²­ì‚° ê¸°íšŒ ë°ì´í„° ì¶”ì¶œ
        let liquidation_opportunity = self.extract_liquidation_opportunity(opportunity).await?;
        
        let user_address = liquidation_opportunity.target_user;
        let collateral_asset = liquidation_opportunity.collateral_asset;
        let debt_asset = liquidation_opportunity.debt_asset;
        let liquidation_amount = liquidation_opportunity.liquidation_amount;
        let protocol = &liquidation_opportunity.protocol;

        // í”„ë¡œí† ì½œë³„ ì²­ì‚° í•¨ìˆ˜ í˜¸ì¶œ ë°ì´í„° ìƒì„±
        let call_data = match protocol.protocol_type {
            crate::strategies::liquidation::types::ProtocolType::Aave => {
                // Aave V3 liquidationCall í•¨ìˆ˜
                self.create_aave_v3_call(
                    collateral_asset,
                    debt_asset,
                    user_address,
                    liquidation_amount
                ).await?
            }
            crate::strategies::liquidation::types::ProtocolType::Compound => {
                // Compound V2 liquidateBorrow í•¨ìˆ˜
                self.create_compound_v2_call(
                    user_address,
                    debt_asset,
                    liquidation_amount,
                    collateral_asset
                ).await?
            }
            crate::strategies::liquidation::types::ProtocolType::MakerDAO => {
                // MakerDAO liquidate í•¨ìˆ˜
                self.create_maker_liquidate_call(
                    user_address,
                    collateral_asset
                ).await?
            }
        };

        // ê°€ìŠ¤ ê°€ê²© ì¡°íšŒ (EIP-1559)
        let (base_fee, priority_fee) = self.blockchain_client.get_gas_price().await?;
        let gas_price_eth = ethers::types::U256::from(base_fee.as_u128()) + ethers::types::U256::from(priority_fee.as_u128());

        // Wallet ì£¼ì†Œ ì¡°íšŒ
        let from_address = self.blockchain_client.get_wallet_address()
            .ok_or_else(|| anyhow::anyhow!("Walletì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. BlockchainClient.new_with_wallet()ì„ ì‚¬ìš©í•˜ì„¸ìš”"))?;

        // Nonce ì¡°íšŒ (ethers Address ê·¸ëŒ€ë¡œ ì‚¬ìš©)
        let nonce = self.blockchain_client.get_nonce(from_address).await?;

        // ethers Addressë¥¼ alloy Addressë¡œ ë³€í™˜
        let from_alloy = Address::from_slice(&from_address.to_fixed_bytes());

        // íŠ¸ëœì­ì…˜ ìƒì„±
        let tx = crate::types::Transaction {
            hash: alloy::primitives::TxHash::ZERO, // ë‚˜ì¤‘ì— ì„œëª… ì‹œ ì„¤ì •
            from: from_alloy,
            to: Some("0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2".parse::<Address>()?), // Aave V3 Pool
            value: U256::ZERO, // ì²­ì‚°ì€ ETH ì „ì†¡ ì—†ìŒ
            gas_price: U256::from(gas_price_eth.as_u128()),
            gas_limit: U256::from(500_000u64), // ì²­ì‚° íŠ¸ëœì­ì…˜ ê°€ìŠ¤ í•œë„
            data: call_data,
            nonce: nonce.as_u64(),
            timestamp: chrono::Utc::now(),
            block_number: None,
        };

        info!("âœ… ì²­ì‚° íŠ¸ëœì­ì…˜ ìƒì„± ì™„ë£Œ: {} -> {} (ê¸ˆì•¡: {} wei)", 
              user_address, protocol.lending_pool_address, liquidation_amount);

        Ok(tx)
    }

    /// Opportunityì—ì„œ ì²­ì‚° ê¸°íšŒ ì •ë³´ ì¶”ì¶œ
    async fn extract_liquidation_opportunity(&self, opportunity: &Opportunity) -> Result<crate::strategies::liquidation::types::OnChainLiquidationOpportunity> {
        info!("ğŸ” ì²­ì‚° ê¸°íšŒ ë°ì´í„° ì¶”ì¶œ ì‹œì‘");
        
        // OpportunityDetailsì—ì„œ LiquidationDetails ì¶”ì¶œ
        let liquidation_details = match &opportunity.details {
            crate::types::OpportunityDetails::Liquidation(details) => details,
            _ => return Err(anyhow::anyhow!("ì˜ëª»ëœ ê¸°íšŒ íƒ€ì…: ì²­ì‚° ê¸°íšŒê°€ ì•„ë‹™ë‹ˆë‹¤")),
        };
        
        // í”„ë¡œí† ì½œ ì •ë³´ ë§¤í•‘
        let protocol = self.map_protocol_info(&liquidation_details.protocol)?;
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ì •ë³´ êµ¬ì„±
        let position = crate::strategies::liquidation::types::UserPosition {
            user: liquidation_details.user,
            protocol: protocol.lending_pool_address,
            collateral_assets: vec![crate::strategies::liquidation::types::CollateralPosition {
                asset: liquidation_details.collateral_asset,
                amount: liquidation_details.collateral_amount,
                usd_value: self.calculate_usd_value(liquidation_details.collateral_asset, liquidation_details.collateral_amount).await?,
                liquidation_threshold: protocol.min_health_factor,
            }],
            debt_assets: vec![crate::strategies::liquidation::types::DebtPosition {
                asset: liquidation_details.debt_asset,
                amount: liquidation_details.debt_amount,
                usd_value: self.calculate_usd_value(liquidation_details.debt_asset, liquidation_details.debt_amount).await?,
                borrow_rate: 0.05, // 5% ê¸°ë³¸ê°’
            }],
            health_factor: liquidation_details.health_factor.to_f64().unwrap_or(0.0),
            liquidation_threshold: protocol.min_health_factor,
            total_collateral_usd: self.calculate_usd_value(liquidation_details.collateral_asset, liquidation_details.collateral_amount).await?,
            total_debt_usd: self.calculate_usd_value(liquidation_details.debt_asset, liquidation_details.debt_amount).await?,
            last_updated: std::time::Instant::now(),
        };
        
        // ìµœì  ì²­ì‚° ê¸ˆì•¡ ê³„ì‚°
        let liquidation_amount = self.calculate_optimal_liquidation_amount(&position, &protocol).await?;
        
        // ì²­ì‚° ë³´ìƒ ê³„ì‚°
        let liquidation_bonus = self.calculate_liquidation_bonus(liquidation_amount, &protocol).await?;
        
        // ê°€ìŠ¤ ë¹„ìš© ì¶”ì •
        let estimated_gas_cost = self.estimate_liquidation_gas_cost(&protocol).await?;
        
        // ì˜ˆìƒ ìˆ˜ìµ ê³„ì‚°
        let estimated_profit = if liquidation_bonus > estimated_gas_cost {
            liquidation_bonus - estimated_gas_cost
        } else {
            U256::ZERO
        };
        
        info!("âœ… ì²­ì‚° ê¸°íšŒ ë°ì´í„° ì¶”ì¶œ ì™„ë£Œ: ì‚¬ìš©ì={:?}, ìˆ˜ìµ={:.4} ETH", 
               liquidation_details.user, 
               estimated_profit.to::<u128>() as f64 / 1e18);
        
        Ok(crate::strategies::liquidation::types::OnChainLiquidationOpportunity {
            target_user: liquidation_details.user,
            protocol,
            position,
            collateral_asset: liquidation_details.collateral_asset,
            debt_asset: liquidation_details.debt_asset,
            liquidation_amount,
            collateral_amount: liquidation_details.collateral_amount,
            liquidation_bonus,
            expected_profit: estimated_profit,
            gas_cost: estimated_gas_cost,
            net_profit: estimated_profit,
            success_probability: 0.8,
        })
    }
    
    /// í”„ë¡œí† ì½œ ì •ë³´ ë§¤í•‘
    fn map_protocol_info(&self, protocol_name: &str) -> Result<crate::strategies::liquidation::types::LendingProtocolInfo> {
        match protocol_name.to_lowercase().as_str() {
            "aave" | "aave v3" => {
                Ok(crate::strategies::liquidation::types::LendingProtocolInfo {
                    name: "Aave V3".to_string(),
                    protocol_type: crate::strategies::liquidation::types::ProtocolType::Aave,
                    lending_pool_address: "0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2".parse::<Address>()?,
                    price_oracle_address: Some("0x54586bE62E3c3580375aE3723C145253060Ca0C2".parse::<Address>()?),
                    liquidation_fee: 500, // 5%
                    min_health_factor: 0.95,
                    supported_assets: vec![
                        "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".parse::<Address>()?, // WETH
                        "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48".parse::<Address>()?, // USDC
                        "0xdAC17F958D2ee523a2206206994597C13D831ec7".parse::<Address>()?, // USDT
                    ],
                })
            },
            "compound" | "compound v2" => {
                Ok(crate::strategies::liquidation::types::LendingProtocolInfo {
                    name: "Compound V2".to_string(),
                    protocol_type: crate::strategies::liquidation::types::ProtocolType::Compound,
                    lending_pool_address: "0x3d9819210A31b4961b30EF54bE2eD79B9c9Cd3B7".parse::<Address>()?,
                    price_oracle_address: Some("0x922018674c12a7F0D394ebEEf9B58F186CdE13c1".parse::<Address>()?),
                    liquidation_fee: 800, // 8%
                    min_health_factor: 0.9,
                    supported_assets: vec![
                        "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".parse::<Address>()?, // WETH
                        "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48".parse::<Address>()?, // USDC
                    ],
                })
            },
            "makerdao" | "maker" => {
                Ok(crate::strategies::liquidation::types::LendingProtocolInfo {
                    name: "MakerDAO".to_string(),
                    protocol_type: crate::strategies::liquidation::types::ProtocolType::MakerDAO,
                    lending_pool_address: "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B".parse::<Address>()?,
                    price_oracle_address: Some("0x729D19f657BD0614b4985Cf1D82531c67569197B".parse::<Address>()?),
                    liquidation_fee: 1300, // 13%
                    min_health_factor: 1.0,
                    supported_assets: vec![
                        "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".parse::<Address>()?, // WETH
                    ],
                })
            },
            _ => Err(anyhow::anyhow!("ì§€ì›í•˜ì§€ ì•ŠëŠ” í”„ë¡œí† ì½œ: {}", protocol_name)),
        }
    }
    
    /// USD ê°€ì¹˜ ê³„ì‚°
    async fn calculate_usd_value(&self, asset: Address, amount: U256) -> Result<f64> {
        // ì‹¤ì œë¡œëŠ” PriceOracleì—ì„œ ê°€ê²©ì„ ì¡°íšŒí•´ì•¼ í•¨
        // í˜„ì¬ëŠ” ê°„ë‹¨í•œ ë§¤í•‘ ì‚¬ìš©
        let price_per_token = match asset.to_string().to_lowercase().as_str() {
            "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2" => 2000.0, // WETH
            "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" => 1.0,    // USDC
            "0xdac17f958d2ee523a2206206994597c13d831ec7" => 1.0,    // USDT
            _ => 0.0,
        };
        
        let amount_f64 = amount.to::<u128>() as f64 / 1e18;
        Ok(amount_f64 * price_per_token)
    }
    
    /// ìµœì  ì²­ì‚° ê¸ˆì•¡ ê³„ì‚°
    async fn calculate_optimal_liquidation_amount(&self, position: &crate::strategies::liquidation::types::UserPosition, protocol: &crate::strategies::liquidation::types::LendingProtocolInfo) -> Result<U256> {
        // ë¶€ì±„ì˜ 50% ë˜ëŠ” ë‹´ë³´ì˜ 50% ì¤‘ ì‘ì€ ê°’
        let max_debt_liquidation = position.total_debt_usd * 0.5;
        let max_collateral_liquidation = position.total_collateral_usd * 0.5;
        let max_liquidation_usd = max_debt_liquidation.min(max_collateral_liquidation);
        
        // USDë¥¼ í† í° ë‹¨ìœ„ë¡œ ë³€í™˜ (ê°„ë‹¨í™”)
        let liquidation_amount = U256::from((max_liquidation_usd * 1e18) as u64);
        
        Ok(liquidation_amount)
    }
    
    /// ì²­ì‚° ë³´ìƒ ê³„ì‚°
    async fn calculate_liquidation_bonus(&self, liquidation_amount: U256, protocol: &crate::strategies::liquidation::types::LendingProtocolInfo) -> Result<U256> {
        let fee_bps = protocol.liquidation_fee as f64;
        let bonus = liquidation_amount * U256::from(fee_bps as u64) / U256::from(10000);
        Ok(bonus)
    }
    
    /// ì²­ì‚° ê°€ìŠ¤ ë¹„ìš© ì¶”ì •
    async fn estimate_liquidation_gas_cost(&self, protocol: &crate::strategies::liquidation::types::LendingProtocolInfo) -> Result<U256> {
        let base_gas = match protocol.protocol_type {
            crate::strategies::liquidation::types::ProtocolType::Aave => 300_000,
            crate::strategies::liquidation::types::ProtocolType::Compound => 400_000,
            crate::strategies::liquidation::types::ProtocolType::MakerDAO => 500_000,
        };
        
        let (base_fee, priority_fee) = self.blockchain_client.get_gas_price().await?;
        let total_gas_cost = U256::from(base_gas) * (U256::from_limbs_slice(&base_fee.0) + U256::from_limbs_slice(&priority_fee.0));
        
        Ok(total_gas_cost)
    }

    /// Aave V3 ì²­ì‚° ì½œ ìƒì„±
    async fn create_aave_v3_call(
        &self,
        collateral: Address,
        debt: Address,
        user: Address,
        debt_amount: U256,
    ) -> Result<Vec<u8>> {
        use ethers::abi::{Function, Param, ParamType, Token};

        // liquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken)
        let function = Function {
            name: "liquidationCall".to_string(),
            inputs: vec![
                Param { name: "collateralAsset".to_string(), kind: ParamType::Address, internal_type: None },
                Param { name: "debtAsset".to_string(), kind: ParamType::Address, internal_type: None },
                Param { name: "user".to_string(), kind: ParamType::Address, internal_type: None },
                Param { name: "debtToCover".to_string(), kind: ParamType::Uint(256), internal_type: None },
                Param { name: "receiveAToken".to_string(), kind: ParamType::Bool, internal_type: None },
            ],
            outputs: vec![],
            constant: None,
            state_mutability: ethers::abi::StateMutability::NonPayable,
        };

        let tokens = vec![
            Token::Address(ethers::types::H160::from_slice(&collateral.0)),
            Token::Address(ethers::types::H160::from_slice(&debt.0)),
            Token::Address(ethers::types::H160::from_slice(&user.0)),
            Token::Uint(ethers::types::U256::from_little_endian(&debt_amount.to_le_bytes::<32>())),
            Token::Bool(false),
        ];

        Ok(function.encode_input(&tokens)?)
    }

    /// Compound V2 ì²­ì‚° ì½œ ìƒì„±
    async fn create_compound_v2_call(
        &self,
        user: Address,
        _debt_token: Address,
        debt_amount: U256,
        collateral_token: Address,
    ) -> Result<Vec<u8>> {
        use ethers::abi::{Function, Param, ParamType, Token};

        // liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)
        let function = Function {
            name: "liquidateBorrow".to_string(),
            inputs: vec![
                Param { name: "borrower".to_string(), kind: ParamType::Address, internal_type: None },
                Param { name: "repayAmount".to_string(), kind: ParamType::Uint(256), internal_type: None },
                Param { name: "cTokenCollateral".to_string(), kind: ParamType::Address, internal_type: None },
            ],
            outputs: vec![],
            constant: None,
            state_mutability: ethers::abi::StateMutability::NonPayable,
        };

        let tokens = vec![
            Token::Address(ethers::types::H160::from_slice(&user.0)),
            Token::Uint(ethers::types::U256::from_little_endian(&debt_amount.to_le_bytes::<32>())),
            Token::Address(ethers::types::H160::from_slice(&collateral_token.0)),
        ];

        Ok(function.encode_input(&tokens)?)
    }

    /// Compound V3 ì²­ì‚° ì½œ ìƒì„±
    async fn create_compound_v3_call(
        &self,
        user: Address,
        collateral: Address,
    ) -> Result<Vec<u8>> {
        // liquidate(address borrower, uint256 repayAmount, address collateralAsset)
        // Note: This is simplified, actual implementation may vary
        let function_selector = [0x5, 0x3, 0x7, 0x3, 0x4, 0x1, 0x7, 0x7]; // liquidate í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜

        let mut data = function_selector.to_vec();

        // borrower
        data.extend_from_slice(user.as_slice());

        // repayAmount (using a default value for now)
        let repay_amount = U256::from(1_000_000_000_000_000_000u64);
        data.extend_from_slice(&repay_amount.to_be_bytes::<32>());

        // collateralAsset
        data.extend_from_slice(collateral.as_slice());

        Ok(data)
    }

    /// MakerDAO ì²­ì‚° í•¨ìˆ˜ ìƒì„±
    async fn create_maker_liquidate_call(
        &self,
        user: Address,
        collateral: Address,
    ) -> Result<Vec<u8>> {
        use ethers::abi::{Function, Param, ParamType, Token};

        info!("ğŸ›ï¸ MakerDAO ì²­ì‚° ì½œ ìƒì„±: user={}, collateral={}", user, collateral);

        // MakerDAO liquidate í•¨ìˆ˜: liquidate(address user, address collateral, uint256 amount)
        let function = Function {
            name: "liquidate".to_string(),
            inputs: vec![
                Param { name: "user".to_string(), kind: ParamType::Address, internal_type: None },
                Param { name: "collateral".to_string(), kind: ParamType::Address, internal_type: None },
                Param { name: "amount".to_string(), kind: ParamType::Uint(256), internal_type: None },
            ],
            outputs: vec![],
            constant: None,
            state_mutability: ethers::abi::StateMutability::NonPayable,
        };

        // ìµœëŒ€ ì²­ì‚° ê¸ˆì•¡ (1 ETH)
        let max_liquidation = ethers::types::U256::from(1_000_000_000_000_000_000u64);

        let tokens = vec![
            Token::Address(ethers::types::H160::from_slice(&user.0)),
            Token::Address(ethers::types::H160::from_slice(&collateral.0)),
            Token::Uint(max_liquidation),
        ];

        let call_data = function.encode_input(&tokens)?;
        info!("âœ… MakerDAO ì²­ì‚° ì½œ ìƒì„± ì™„ë£Œ: {} bytes", call_data.len());
        Ok(call_data)
    }

    /// í”„ë¼ì´ë¹— ì²­ì‚° ì œì¶œ (MEV-lite ë©€í‹° ë¦´ë ˆì´)
    async fn submit_private(
        &self,
        tx: Transaction,
        tip: U256,
    ) -> Result<PrivateSubmissionResult> {
        info!("ğŸ”’ MEV-lite ë©€í‹° ë¦´ë ˆì´ ì œì¶œ ì‹œì‘");
        
        // 1. ë¦´ë ˆì´ ìš°ì„ ìˆœìœ„ ì„¤ì •
        let relay_configs = self.get_relay_configurations().await?;
        
        // 2. ë³‘ë ¬ë¡œ ëª¨ë“  ë¦´ë ˆì´ì— ì œì¶œ
        let submission_tasks = relay_configs.iter().map(|config| {
            let tx_clone = tx.clone();
            let tip_clone = tip;
            let config_clone = config.clone();
            
            tokio::spawn(async move {
                self.submit_to_relay(&config_clone, &tx_clone, tip_clone).await
            })
        }).collect::<Vec<_>>();
        
        // 3. ê²°ê³¼ ìˆ˜ì§‘ ë° ë¶„ì„
        let mut results = Vec::new();
        for task in submission_tasks {
            match task.await {
                Ok(Ok(result)) => results.push(result),
                Ok(Err(e)) => {
                    warn!("ë¦´ë ˆì´ ì œì¶œ ì˜¤ë¥˜: {}", e);
                }
                Err(e) => {
                    warn!("ë¦´ë ˆì´ íƒœìŠ¤í¬ ì˜¤ë¥˜: {}", e);
                }
            }
        }
        
        // 4. ìµœì  ê²°ê³¼ ì„ íƒ
        let best_result = self.select_best_result(&results).await?;
        
        if best_result.success {
            info!("âœ… MEV-lite ì œì¶œ ì„±ê³µ: {} ë¦´ë ˆì´", best_result.relay_name);
        } else {
            warn!("âŒ ëª¨ë“  MEV-lite ë¦´ë ˆì´ ì‹¤íŒ¨");
        }
        
        Ok(best_result)
    }
    
    /// ë¦´ë ˆì´ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
    async fn get_relay_configurations(&self) -> Result<Vec<RelayConfig>> {
        Ok(vec![
            RelayConfig {
                name: "flashbots-protect".to_string(),
                url: "https://relay.flashbots.net".to_string(),
                priority: 1,
                timeout_ms: 2000,
                max_retries: 2,
                weight: 0.3,
            },
            RelayConfig {
                name: "builder0x69".to_string(),
                url: "https://builder0x69.io".to_string(),
                priority: 2,
                timeout_ms: 1500,
                max_retries: 2,
                weight: 0.25,
            },
            RelayConfig {
                name: "beaver-build".to_string(),
                url: "https://beaverbuild.org".to_string(),
                priority: 3,
                timeout_ms: 1000,
                max_retries: 1,
                weight: 0.2,
            },
            RelayConfig {
                name: "rsync-builder".to_string(),
                url: "https://rsync-builder.xyz".to_string(),
                priority: 4,
                timeout_ms: 1000,
                max_retries: 1,
                weight: 0.15,
            },
            RelayConfig {
                name: "titan-builder".to_string(),
                url: "https://titan-builder.xyz".to_string(),
                priority: 5,
                timeout_ms: 800,
                max_retries: 1,
                weight: 0.1,
            },
        ])
    }
    
    /// íŠ¹ì • ë¦´ë ˆì´ì— ì œì¶œ
    async fn submit_to_relay(
        &self,
        config: &RelayConfig,
        tx: &Transaction,
        tip: U256,
    ) -> Result<PrivateSubmissionResult> {
        let start_time = std::time::Instant::now();
        
        for attempt in 1..=config.max_retries {
            match self.try_relay_submission(config, tx, tip).await {
                Ok(result) => {
                    let duration = start_time.elapsed();
                    info!("âœ… {} ë¦´ë ˆì´ ì œì¶œ ì„±ê³µ (ì‹œë„: {}, ì‹œê°„: {}ms)", 
                           config.name, attempt, duration.as_millis());
                    return Ok(result);
                }
                Err(e) => {
                    if attempt < config.max_retries {
                        warn!("âš ï¸ {} ë¦´ë ˆì´ ì‹œë„ {} ì‹¤íŒ¨: {}, ì¬ì‹œë„ ì¤‘...", 
                               config.name, attempt, e);
                        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                    } else {
                        warn!("âŒ {} ë¦´ë ˆì´ ìµœì¢… ì‹¤íŒ¨: {}", config.name, e);
                    }
                }
            }
        }
        
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some(format!("{} relay failed after {} attempts", config.name, config.max_retries)),
            relay_name: Some(config.name.clone()),
        })
    }
    
    /// ë¦´ë ˆì´ ì œì¶œ ì‹œë„
    async fn try_relay_submission(
        &self,
        config: &RelayConfig,
        tx: &Transaction,
        tip: U256,
    ) -> Result<PrivateSubmissionResult> {
        let client = reqwest::Client::builder()
            .timeout(tokio::time::Duration::from_millis(config.timeout_ms))
            .build()?;
        
        // ë¦´ë ˆì´ë³„ íŠ¹í™”ëœ í˜ì´ë¡œë“œ ìƒì„±
        let payload = self.create_relay_payload(config, tx, tip).await?;
        
        let response = client
            .post(&config.url)
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            let response_text = response.text().await?;
            self.parse_relay_response(config, &response_text).await
        } else {
            Err(anyhow::anyhow!("HTTP {}: {}", response.status(), response.text().await?))
        }
    }
    
    /// ë¦´ë ˆì´ë³„ í˜ì´ë¡œë“œ ìƒì„±
    async fn create_relay_payload(
        &self,
        config: &RelayConfig,
        tx: &Transaction,
        tip: U256,
    ) -> Result<serde_json::Value> {
        match config.name.as_str() {
            "flashbots-protect" => {
                Ok(serde_json::json!({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "eth_sendBundle",
                    "params": [{
                        "txs": [format!("0x{}", hex::encode(&tx.data))],
                        "blockNumber": format!("0x{:x}", self.get_target_block().await?),
                        "minTimestamp": 0,
                        "maxTimestamp": 0,
                        "revertingTxHashes": []
                    }]
                }))
            }
            "builder0x69" => {
                Ok(serde_json::json!({
                    "method": "submit_bundle",
                    "params": {
                        "transactions": [format!("0x{}", hex::encode(&tx.data))],
                        "target_block": self.get_target_block().await?,
                        "priority_fee": format!("0x{:x}", tip)
                    }
                }))
            }
            "beaver-build" => {
                Ok(serde_json::json!({
                    "bundle": {
                        "transactions": [format!("0x{}", hex::encode(&tx.data))],
                        "target_block": self.get_target_block().await?,
                        "tip": format!("0x{:x}", tip)
                    }
                }))
            }
            "rsync-builder" => {
                Ok(serde_json::json!({
                    "txs": [format!("0x{}", hex::encode(&tx.data))],
                    "block": self.get_target_block().await?,
                    "priority": tip.to_string()
                }))
            }
            "titan-builder" => {
                Ok(serde_json::json!({
                    "bundle_data": {
                        "transactions": [format!("0x{}", hex::encode(&tx.data))],
                        "target_block_number": self.get_target_block().await?,
                        "tip_amount": format!("0x{:x}", tip)
                    }
                }))
            }
            _ => Err(anyhow::anyhow!("Unknown relay: {}", config.name))
        }
    }
    
    /// ë¦´ë ˆì´ ì‘ë‹µ íŒŒì‹±
    async fn parse_relay_response(
        &self,
        config: &RelayConfig,
        response: &str,
    ) -> Result<PrivateSubmissionResult> {
        let json_response: serde_json::Value = serde_json::from_str(response)?;
        
        match config.name.as_str() {
            "flashbots-protect" => {
                if let Some(result) = json_response.get("result") {
                    if let Some(bundle_hash) = result.get("bundleHash") {
                        return Ok(PrivateSubmissionResult {
                            success: true,
                            bundle_hash: Some(bundle_hash.as_str().unwrap().to_string()),
                            error: None,
                            relay_name: Some(config.name.clone()),
                        });
                    }
                }
            }
            "builder0x69" => {
                if let Some(success) = json_response.get("success") {
                    if success.as_bool().unwrap_or(false) {
                        return Ok(PrivateSubmissionResult {
                            success: true,
                            bundle_hash: json_response.get("bundle_id").and_then(|v| v.as_str()).map(|s| s.to_string()),
                            error: None,
                            relay_name: Some(config.name.clone()),
                        });
                    }
                }
            }
            "beaver-build" => {
                if let Some(status) = json_response.get("status") {
                    if status.as_str() == Some("accepted") {
                        return Ok(PrivateSubmissionResult {
                            success: true,
                            bundle_hash: json_response.get("bundle_id").and_then(|v| v.as_str()).map(|s| s.to_string()),
                            error: None,
                            relay_name: Some(config.name.clone()),
                        });
                    }
                }
            }
            "rsync-builder" => {
                if let Some(accepted) = json_response.get("accepted") {
                    if accepted.as_bool().unwrap_or(false) {
                        return Ok(PrivateSubmissionResult {
                            success: true,
                            bundle_hash: json_response.get("bundle_hash").and_then(|v| v.as_str()).map(|s| s.to_string()),
                            error: None,
                            relay_name: Some(config.name.clone()),
                        });
                    }
                }
            }
            "titan-builder" => {
                if let Some(result) = json_response.get("result") {
                    if result.as_str() == Some("success") {
                        return Ok(PrivateSubmissionResult {
                            success: true,
                            bundle_hash: json_response.get("bundle_id").and_then(|v| v.as_str()).map(|s| s.to_string()),
                            error: None,
                            relay_name: Some(config.name.clone()),
                        });
                    }
                }
            }
            _ => {}
        }
        
        // ì‹¤íŒ¨í•œ ê²½ìš°
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some(format!("{} relay rejected the bundle", config.name)),
            relay_name: Some(config.name.clone()),
        })
    }
    
    /// ìµœì  ê²°ê³¼ ì„ íƒ
    async fn select_best_result(&self, results: &[PrivateSubmissionResult]) -> Result<PrivateSubmissionResult> {
        // 1. ì„±ê³µí•œ ê²°ê³¼ë“¤ ì¤‘ì—ì„œ ì„ íƒ
        let successful_results: Vec<_> = results.iter()
            .filter(|r| r.success)
            .collect();
        
        if successful_results.is_empty() {
            // ëª¨ë“  ê²°ê³¼ê°€ ì‹¤íŒ¨í•œ ê²½ìš°, ê°€ì¥ ìµœê·¼ ì—ëŸ¬ ë°˜í™˜
            return Ok(results.last().unwrap().clone());
        }
        
        // 2. ê°€ì¤‘ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ìµœì  ê²°ê³¼ ì„ íƒ
        let mut best_result = &successful_results[0];
        let mut best_score = 0.0;
        
        for result in &successful_results {
            let score = self.calculate_result_score(result).await?;
            if score > best_score {
                best_score = score;
                best_result = result;
            }
        }
        
        info!("ğŸ† ìµœì  ë¦´ë ˆì´ ì„ íƒ: {} (ì ìˆ˜: {:.2})", 
               best_result.relay_name.as_deref().unwrap_or("unknown"), best_score);
        
        Ok(best_result.clone())
    }
    
    /// ê²°ê³¼ ì ìˆ˜ ê³„ì‚°
    async fn calculate_result_score(&self, result: &PrivateSubmissionResult) -> Result<f64> {
        let mut score = 0.0;
        
        // ë¦´ë ˆì´ë³„ ê°€ì¤‘ì¹˜
        if let Some(relay_name) = &result.relay_name {
            let weight = match relay_name.as_str() {
                "flashbots-protect" => 0.3,
                "builder0x69" => 0.25,
                "beaver-build" => 0.2,
                "rsync-builder" => 0.15,
                "titan-builder" => 0.1,
                _ => 0.1,
            };
            score += weight * 100.0;
        }
        
        // Bundle hashê°€ ìˆìœ¼ë©´ ì¶”ê°€ ì ìˆ˜
        if result.bundle_hash.is_some() {
            score += 10.0;
        }
        
        // ì—ëŸ¬ê°€ ì—†ìœ¼ë©´ ì¶”ê°€ ì ìˆ˜
        if result.error.is_none() {
            score += 5.0;
        }
        
        Ok(score)
    }
    
    /// ëŒ€ìƒ ë¸”ë¡ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
    async fn get_target_block(&self) -> Result<u64> {
        let current_block = self.blockchain_client.get_current_block().await?;
        Ok(current_block + 1) // ë‹¤ìŒ ë¸”ë¡ì„ ëŒ€ìƒìœ¼ë¡œ
    }

    /// í¼ë¸”ë¦­ ì²­ì‚° ë¸Œë¡œë“œìºìŠ¤íŠ¸
    async fn broadcast_public(&self, tx: Transaction) -> Result<bool> {
        info!("ğŸ“¡ í¼ë¸”ë¦­ ë©¤í’€ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì‹œì‘");

        // íŠ¸ëœì­ì…˜ì„ ethers íƒ€ì…ìœ¼ë¡œ ë³€í™˜
        let ethers_tx = ethers::types::TransactionRequest::new()
            .to(ethers::types::H160::from_slice(tx.to.unwrap_or(Address::ZERO).as_slice()))
            .value(ethers::types::U256::from_str_radix(&tx.value.to_string(), 10).unwrap_or_default())
            .gas(ethers::types::U256::from_str_radix(&tx.gas_limit.to_string(), 10).unwrap_or_default())
            .gas_price(ethers::types::U256::from_str_radix(&tx.gas_price.to_string(), 10).unwrap_or_default())
            .data(ethers::types::Bytes::from(tx.data.clone()))
            .nonce(tx.nonce);

        // ì‹¤ì œ íŠ¸ëœì­ì…˜ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        match self.blockchain_client.send_transaction(ethers_tx).await {
            Ok(tx_hash) => {
                info!("âœ… í¼ë¸”ë¦­ íŠ¸ëœì­ì…˜ ì œì¶œ ì„±ê³µ: {}", tx_hash);
                Ok(true)
            }
            Err(e) => {
                warn!("âŒ í¼ë¸”ë¦­ íŠ¸ëœì­ì…˜ ì œì¶œ ì‹¤íŒ¨: {}", e);
                Ok(false)
            }
        }
    }

    /// ë™ì  íŒ ê³„ì‚° (ê²½ìŸ ë¶„ì„ í¬í•¨)
    async fn calculate_dynamic_tip(&self, opportunity: &Opportunity) -> Result<U256> {
        info!("ğŸ’° ë™ì  íŒ ê³„ì‚° ì‹œì‘");
        
        // 1. ì‹¤ì‹œê°„ ê²½ìŸ ë¶„ì„
        let competition_analysis = self.analyze_real_time_competition(opportunity).await?;
        
        // 2. ê°€ìŠ¤ ê°€ê²© íŠ¸ë Œë“œ ë¶„ì„
        let gas_trend_analysis = self.analyze_gas_trend().await?;
        
        // 3. ê¸°íšŒ ìš°ì„ ìˆœìœ„ ë¶„ì„
        let opportunity_priority = self.analyze_opportunity_priority(opportunity).await?;
        
        // 4. ê¸°ë³¸ íŒ ê³„ì‚° (ìˆ˜ìµì„± ê¸°ë°˜)
        let base_tip = self.calculate_base_tip(opportunity, &opportunity_priority).await?;
        
        // 5. ê²½ìŸ ê¸°ë°˜ ë™ì  ì¡°ì •
        let competition_adjustment = self.calculate_competition_adjustment(&competition_analysis).await?;
        
        // 6. ê°€ìŠ¤ íŠ¸ë Œë“œ ê¸°ë°˜ ì¡°ì •
        let gas_trend_adjustment = self.calculate_gas_trend_adjustment(&gas_trend_analysis).await?;
        
        // 7. ì‹œì¥ ìƒí™© ê¸°ë°˜ ì¡°ì •
        let market_adjustment = self.calculate_market_adjustment(opportunity).await?;
        
        // 8. ìµœì¢… íŒ ê³„ì‚°
        let final_tip = self.combine_tip_adjustments(
            base_tip,
            competition_adjustment,
            gas_trend_adjustment,
            market_adjustment,
            opportunity
        ).await?;
        
        info!("ğŸ“Š ë™ì  íŒ ê³„ì‚° ì™„ë£Œ: ê¸°ë³¸={:.4} ETH, ê²½ìŸ={:.1}x, ê°€ìŠ¤={:.1}x, ì‹œì¥={:.1}x, ìµœì¢…={:.4} ETH",
              Self::format_eth_amount(base_tip),
              competition_adjustment.multiplier,
              gas_trend_adjustment.multiplier,
              market_adjustment.multiplier,
              Self::format_eth_amount(final_tip));
        
        Ok(final_tip)
    }
    
    /// ì‹¤ì‹œê°„ ê²½ìŸ ë¶„ì„
    async fn analyze_real_time_competition(&self, opportunity: &Opportunity) -> Result<CompetitionAnalysis> {
        // 1. ë©¤í’€ì—ì„œ ìœ ì‚¬í•œ ì²­ì‚° íŠ¸ëœì­ì…˜ ìŠ¤ìº”
        let mempool_competitors = self.scan_mempool_competitors(opportunity).await?;
        
        // 2. ìµœê·¼ ë¸”ë¡ì—ì„œ ê²½ìŸì ë¶„ì„
        let historical_competitors = self.analyze_historical_competitors(opportunity).await?;
        
        // 3. ê²½ìŸ ê°•ë„ ê³„ì‚°
        let competition_intensity = self.calculate_competition_intensity(&mempool_competitors, &historical_competitors).await?;
        
        Ok(CompetitionAnalysis {
            mempool_competitors,
            historical_competitors,
            competition_intensity,
            analysis_timestamp: chrono::Utc::now(),
        })
    }
    
    /// ë©¤í’€ ê²½ìŸì ìŠ¤ìº”
    async fn scan_mempool_competitors(&self, opportunity: &Opportunity) -> Result<Vec<MempoolCompetitor>> {
        let mut competitors = Vec::new();
        
        // ì‹¤ì œë¡œëŠ” WebSocketìœ¼ë¡œ ì‹¤ì‹œê°„ ë©¤í’€ ëª¨ë‹ˆí„°ë§
        // í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜
        let simulated_competitors = vec![
            MempoolCompetitor {
                address: "0x1234567890123456789012345678901234567890".parse().unwrap(),
                gas_price: U256::from(25_000_000_000u64), // 25 gwei
                estimated_profit: U256::from(50000000000000000u64), // 0.05 ETH
                time_to_execution: 12, // 12ì´ˆ
            },
            MempoolCompetitor {
                address: "0x2345678901234567890123456789012345678901".parse().unwrap(),
                gas_price: U256::from(30_000_000_000u64), // 30 gwei
                estimated_profit: U256::from(30000000000000000u64), // 0.03 ETH
                time_to_execution: 8, // 8ì´ˆ
            },
        ];
        
        Ok(simulated_competitors)
    }
    
    /// ê³¼ê±° ê²½ìŸì ë¶„ì„
    async fn analyze_historical_competitors(&self, opportunity: &Opportunity) -> Result<Vec<HistoricalCompetitor>> {
        let mut competitors = Vec::new();
        
        // ìµœê·¼ 10ê°œ ë¸”ë¡ì—ì„œ ì²­ì‚° íŠ¸ëœì­ì…˜ ë¶„ì„
        let current_block = self.blockchain_client.get_current_block().await?;
        
        for block_offset in 1..=10 {
            let block_number = current_block - block_offset;
            if let Some(block) = self.blockchain_client.get_block(block_number).await? {
                if let Some(transactions) = block.transactions {
                    for tx in transactions {
                        if self.is_liquidation_transaction(&tx).await? {
                            competitors.push(HistoricalCompetitor {
                                address: tx.from,
                                gas_price: tx.gas_price.unwrap_or_default(),
                                success: true, // ê°„ë‹¨í™”
                                block_number,
                                profit_earned: U256::from(100000000000000000u64), // 0.1 ETH ê°€ì •
                            });
                        }
                    }
                }
            }
        }
        
        Ok(competitors)
    }
    
    /// ê²½ìŸ ê°•ë„ ê³„ì‚°
    async fn calculate_competition_intensity(
        &self,
        mempool: &[MempoolCompetitor],
        historical: &[HistoricalCompetitor],
    ) -> Result<CompetitionIntensity> {
        let mempool_count = mempool.len();
        let historical_avg_gas = if !historical.is_empty() {
            let total_gas: u64 = historical.iter()
                .map(|c| c.gas_price.to::<u128>() as u64)
                .sum();
            total_gas / historical.len() as u64
        } else {
            20_000_000_000 // 20 gwei ê¸°ë³¸ê°’
        };
        
        let intensity = if mempool_count >= 5 {
            CompetitionIntensity::VeryHigh
        } else if mempool_count >= 3 {
            CompetitionIntensity::High
        } else if mempool_count >= 1 {
            CompetitionIntensity::Medium
        } else {
            CompetitionIntensity::Low
        };
        
        Ok(intensity)
    }
    
    /// ê°€ìŠ¤ íŠ¸ë Œë“œ ë¶„ì„
    async fn analyze_gas_trend(&self) -> Result<GasTrendAnalysis> {
        // ìµœê·¼ 20ê°œ ë¸”ë¡ì˜ ê°€ìŠ¤ ê°€ê²© ë¶„ì„
        let current_block = self.blockchain_client.get_current_block().await?;
        let mut gas_prices = Vec::new();
        
        for block_offset in 1..=20 {
            let block_number = current_block - block_offset;
            if let Some(block) = self.blockchain_client.get_block(block_number).await? {
                if let Some(base_fee) = block.base_fee_per_gas {
                    gas_prices.push(base_fee.to::<u128>() as u64);
                }
            }
        }
        
        if gas_prices.len() < 10 {
            return Ok(GasTrendAnalysis {
                trend: GasTrend::Stable,
                volatility: 0.1,
                multiplier: 1.0,
            });
        }
        
        // íŠ¸ë Œë“œ ê³„ì‚° (ì„ í˜• íšŒê·€)
        let n = gas_prices.len() as f64;
        let sum_x: f64 = (0..gas_prices.len()).map(|i| i as f64).sum();
        let sum_y: f64 = gas_prices.iter().map(|&p| p as f64).sum();
        let sum_xy: f64 = gas_prices.iter().enumerate().map(|(i, &p)| i as f64 * p as f64).sum();
        let sum_x2: f64 = (0..gas_prices.len()).map(|i| (i as f64).powi(2)).sum();
        
        let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x.powi(2));
        
        // ë³€ë™ì„± ê³„ì‚°
        let mean = sum_y / n;
        let variance: f64 = gas_prices.iter()
            .map(|&p| ((p as f64 - mean) / mean).powi(2))
            .sum::<f64>() / n;
        let volatility = variance.sqrt();
        
        let trend = if slope > 0.05 {
            GasTrend::Rising
        } else if slope < -0.05 {
            GasTrend::Falling
        } else {
            GasTrend::Stable
        };
        
        let multiplier = match trend {
            GasTrend::Rising => 1.2,
            GasTrend::Falling => 0.9,
            GasTrend::Stable => 1.0,
        };
        
        Ok(GasTrendAnalysis {
            trend,
            volatility,
            multiplier,
        })
    }
    
    /// ê¸°íšŒ ìš°ì„ ìˆœìœ„ ë¶„ì„
    async fn analyze_opportunity_priority(&self, opportunity: &Opportunity) -> Result<OpportunityPriority> {
        let profit_score = opportunity.expected_profit.to::<u128>() as f64 / 1e18;
        let confidence_score = opportunity.confidence;
        let urgency_score = self.calculate_urgency_score(opportunity).await?;
        
        let priority = if profit_score > 1.0 && confidence_score > 0.8 && urgency_score > 0.7 {
            OpportunityPriority::Critical
        } else if profit_score > 0.5 && confidence_score > 0.6 && urgency_score > 0.5 {
            OpportunityPriority::High
        } else if profit_score > 0.1 && confidence_score > 0.4 {
            OpportunityPriority::Medium
        } else {
            OpportunityPriority::Low
        };
        
        Ok(priority)
    }
    
    /// ê¸´ê¸‰ë„ ì ìˆ˜ ê³„ì‚°
    async fn calculate_urgency_score(&self, opportunity: &Opportunity) -> Result<f64> {
        // ë§Œë£Œ ì‹œê°„ê¹Œì§€ ë‚¨ì€ ì‹œê°„ ê³„ì‚°
        let now = chrono::Utc::now();
        let time_remaining = opportunity.expiry_block as i64 - now.timestamp();
        
        if time_remaining <= 0 {
            return Ok(0.0); // ì´ë¯¸ ë§Œë£Œ
        }
        
        // 5ë¶„ ì´ë‚´ë©´ ë†’ì€ ê¸´ê¸‰ë„
        if time_remaining <= 300 {
            Ok(1.0)
        } else if time_remaining <= 600 {
            Ok(0.8)
        } else if time_remaining <= 1800 {
            Ok(0.5)
        } else {
            Ok(0.2)
        }
    }
    
    /// ê¸°ë³¸ íŒ ê³„ì‚°
    async fn calculate_base_tip(&self, opportunity: &Opportunity, priority: &OpportunityPriority) -> Result<U256> {
        let base_percentage = match priority {
            OpportunityPriority::Critical => 30, // 30%
            OpportunityPriority::High => 25,     // 25%
            OpportunityPriority::Medium => 20,   // 20%
            OpportunityPriority::Low => 15,      // 15%
        };
        
        let base_tip = opportunity.expected_profit * U256::from(base_percentage) / U256::from(100);
        Ok(base_tip)
    }
    
    /// ê²½ìŸ ê¸°ë°˜ ì¡°ì • ê³„ì‚°
    async fn calculate_competition_adjustment(&self, analysis: &CompetitionAnalysis) -> Result<TipAdjustment> {
        let multiplier = match analysis.competition_intensity {
            CompetitionIntensity::Low => 1.0,
            CompetitionIntensity::Medium => 1.3,
            CompetitionIntensity::High => 1.8,
            CompetitionIntensity::VeryHigh => 2.5,
        };
        
        Ok(TipAdjustment {
            multiplier,
            reason: "Competition analysis".to_string(),
        })
    }
    
    /// ê°€ìŠ¤ íŠ¸ë Œë“œ ê¸°ë°˜ ì¡°ì • ê³„ì‚°
    async fn calculate_gas_trend_adjustment(&self, analysis: &GasTrendAnalysis) -> Result<TipAdjustment> {
        let mut multiplier = analysis.multiplier;
        
        // ë³€ë™ì„±ì´ ë†’ìœ¼ë©´ ì¶”ê°€ ì¡°ì •
        if analysis.volatility > 0.3 {
            multiplier *= 1.1;
        }
        
        Ok(TipAdjustment {
            multiplier,
            reason: format!("Gas trend: {:?}", analysis.trend),
        })
    }
    
    /// ì‹œì¥ ìƒí™© ê¸°ë°˜ ì¡°ì • ê³„ì‚°
    async fn calculate_market_adjustment(&self, opportunity: &Opportunity) -> Result<TipAdjustment> {
        // ì‹œì¥ ìƒí™© ë¶„ì„ (ê°„ë‹¨í™”)
        let market_volatility = 0.2; // 20% ë³€ë™ì„± ê°€ì •
        let market_trend = 0.1; // 10% ìƒìŠ¹ ì¶”ì„¸ ê°€ì •
        
        let multiplier = 1.0 + market_volatility + market_trend;
        
        Ok(TipAdjustment {
            multiplier,
            reason: "Market conditions".to_string(),
        })
    }
    
    /// íŒ ì¡°ì • ê²°í•©
    async fn combine_tip_adjustments(
        &self,
        base_tip: U256,
        competition: TipAdjustment,
        gas_trend: TipAdjustment,
        market: TipAdjustment,
        opportunity: &Opportunity,
    ) -> Result<U256> {
        // ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ì¡°ì • ìŠ¹ìˆ˜ ê³„ì‚°
        let total_multiplier = (competition.multiplier * 0.4 + 
                               gas_trend.multiplier * 0.3 + 
                               market.multiplier * 0.3);
        
        let adjusted_tip = base_tip * U256::from((total_multiplier * 100.0) as u64) / U256::from(100);
        
        // ìµœì†Œ/ìµœëŒ€ ì œí•œ
        let min_tip = U256::from(10000000000000000u64); // 0.01 ETH
        let max_tip = opportunity.expected_profit * U256::from(90) / U256::from(100); // ìµœëŒ€ 90%
        
        let final_tip = adjusted_tip.max(min_tip).min(max_tip);
        
        debug!("ğŸ”§ íŒ ì¡°ì • ìƒì„¸: ê¸°ë³¸={:.4} ETH, ê²½ìŸ={:.2}x, ê°€ìŠ¤={:.2}x, ì‹œì¥={:.2}x, ì´í•©={:.2}x, ìµœì¢…={:.4} ETH",
               Self::format_eth_amount(base_tip),
               competition.multiplier,
               gas_trend.multiplier,
               market.multiplier,
               total_multiplier,
               Self::format_eth_amount(final_tip));
        
        Ok(final_tip)
    }

    /// ê²½ìŸ ìƒí™© ë¶„ì„
    async fn analyze_competition(&self, opportunity: &Opportunity) -> Result<CompetitionLevel> {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë©¤í’€ì„ ë¶„ì„í•˜ì—¬ ê²½ìŸì ìˆ˜ë¥¼ íŒŒì•…í•´ì•¼ í•¨
        // í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ë”ë¯¸ ë°ì´í„° ë°˜í™˜
        
        // 1. ë™ì¼í•œ ì²­ì‚° ê¸°íšŒë¥¼ ë…¸ë¦¬ëŠ” ë‹¤ë¥¸ ë´‡ë“¤ ë¶„ì„
        // 2. ìµœê·¼ ì²­ì‚° ì„±ê³µë¥  ë¶„ì„
        // 3. ê°€ìŠ¤ ê°€ê²© ê²½ìŸ ìˆ˜ì¤€ ë¶„ì„
        
        // ì‹œë®¬ë ˆì´ì…˜: ëœë¤í•˜ê²Œ ê²½ìŸ ìˆ˜ì¤€ ê²°ì •
        let random_value = (std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() % 4) as u8;
        
        let competition_level = match random_value {
            0 => CompetitionLevel::Low,
            1 => CompetitionLevel::Medium,
            2 => CompetitionLevel::High,
            _ => CompetitionLevel::VeryHigh,
        };
        
        info!("ğŸ” ê²½ìŸ ë¶„ì„: {:?}", competition_level);
        Ok(competition_level)
    }

    /// ê°€ìŠ¤ ì¡°ê±´ ë¶„ì„
    async fn analyze_gas_conditions(&self) -> Result<GasAnalysis> {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìµœê·¼ ë¸”ë¡ë“¤ì˜ ê°€ìŠ¤ ê°€ê²©ì„ ë¶„ì„í•´ì•¼ í•¨
        
        // 1. ìµœê·¼ ë¸”ë¡ë“¤ì˜ í‰ê·  ê°€ìŠ¤ ê°€ê²©
        // 2. ê°€ìŠ¤ ê°€ê²© ì¶”ì„¸ ë¶„ì„
        // 3. ë„¤íŠ¸ì›Œí¬ í˜¼ì¡ë„ ë¶„ì„
        
        let current_gas_price = 20.0; // gwei (ì‹œë®¬ë ˆì´ì…˜)
        let is_high_gas = current_gas_price > 50.0;
        
        let analysis = GasAnalysis {
            current_gas_price,
            is_high_gas,
            trend: GasTrend::Stable,
            network_congestion: 0.5,
        };
        
        info!("â›½ ê°€ìŠ¤ ë¶„ì„: {:.1} gwei, ë†’ìŒ={}, í˜¼ì¡ë„={:.1}%",
              analysis.current_gas_price,
              analysis.is_high_gas,
              analysis.network_congestion * 100.0);
        
        Ok(analysis)
    }

    /// ETH ê¸ˆì•¡ í¬ë§·íŒ… í—¬í¼
    fn format_eth_amount(amount: U256) -> String {
        let eth_amount = amount.to::<u128>() as f64 / 1e18;
        format!("{:.4}", eth_amount)
    }

    /// í”„ë¼ì´ë¹— ë¦´ë ˆì´ ì‹œë„
    async fn try_private_relay(
        &self,
        relay_name: &str,
        tx: &Transaction,
        tip: U256,
    ) -> Result<PrivateSubmissionResult> {
        info!("ğŸ”— {} ë¦´ë ˆì´ë¡œ í”„ë¼ì´ë¹— ì œì¶œ ì‹œë„", relay_name);
        
        match relay_name {
            "flashbots-protect" => {
                self.try_flashbots_protect(tx, tip).await
            }
            "builder0x69" => {
                self.try_builder0x69(tx, tip).await
            }
            "beaver-build" => {
                self.try_beaver_build(tx, tip).await
            }
            "rsync-builder" => {
                self.try_rsync_builder(tx, tip).await
            }
            "titan-builder" => {
                self.try_titan_builder(tx, tip).await
            }
            _ => {
                Ok(PrivateSubmissionResult {
                    success: false,
                    bundle_hash: None,
                    error: Some(format!("Unknown relay: {}", relay_name)),
                    relay_name: Some(relay_name.to_string()),
                })
            }
        }
    }

    /// Flashbots Protect RPC ì œì¶œ
    async fn try_flashbots_protect(&self, tx: &Transaction, tip: U256) -> Result<PrivateSubmissionResult> {
        let client = reqwest::Client::new();
        let url = "https://relay.flashbots.net";
        
        // Flashbots Protect API ìš”ì²­ êµ¬ì„±
        let payload = serde_json::json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "eth_sendBundle",
            "params": [{
                "txs": [format!("0x{}", hex::encode(&tx.data))],
                "blockNumber": format!("0x{:x}", tx.block_number.unwrap_or(0)),
                "minTimestamp": 0,
                "maxTimestamp": 0,
                "revertingTxHashes": []
            }]
        });
        
        let response = client
            .post(url)
            .header("Content-Type", "application/json")
            .header("X-Flashbots-Signature", self.generate_flashbots_signature(&payload))
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            if let Some(bundle_hash) = result.get("result").and_then(|r| r.as_str()) {
                info!("âœ… Flashbots Protect ì œì¶œ ì„±ê³µ: {}", bundle_hash);
                return Ok(PrivateSubmissionResult {
                    success: true,
                    bundle_hash: Some(bundle_hash.to_string()),
                    error: None,
                });
            }
        }
        
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some("Flashbots Protect submission failed".to_string()),
        })
    }

    /// Builder0x69 ì œì¶œ
    async fn try_builder0x69(&self, tx: &Transaction, tip: U256) -> Result<PrivateSubmissionResult> {
        let client = reqwest::Client::new();
        let url = "https://builder0x69.io/api/v1/bundle";
        
        let payload = serde_json::json!({
            "transactions": [format!("0x{}", hex::encode(&tx.data))],
            "block_number": tx.block_number.unwrap_or(0),
            "priority_fee": tip.to_string()
        });
        
        let response = client
            .post(url)
            .header("Content-Type", "application/json")
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            if let Some(bundle_id) = result.get("bundle_id").and_then(|id| id.as_str()) {
                info!("âœ… Builder0x69 ì œì¶œ ì„±ê³µ: {}", bundle_id);
                return Ok(PrivateSubmissionResult {
                    success: true,
                    bundle_hash: Some(bundle_id.to_string()),
                    error: None,
                });
            }
        }
        
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some("Builder0x69 submission failed".to_string()),
        })
    }

    /// Beaver Build ì œì¶œ
    async fn try_beaver_build(&self, tx: &Transaction, _tip: U256) -> Result<PrivateSubmissionResult> {
        let client = reqwest::Client::new();
        let url = "https://beaverbuild.org/api/v1/submit";
        
        let payload = serde_json::json!({
            "txs": [format!("0x{}", hex::encode(&tx.data))],
            "block_number": tx.block_number.unwrap_or(0)
        });
        
        let response = client
            .post(url)
            .header("Content-Type", "application/json")
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            if let Some(bundle_id) = result.get("bundle_id").and_then(|id| id.as_str()) {
                info!("âœ… Beaver Build ì œì¶œ ì„±ê³µ: {}", bundle_id);
                return Ok(PrivateSubmissionResult {
                    success: true,
                    bundle_hash: Some(bundle_id.to_string()),
                    error: None,
                });
            }
        }
        
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some("Beaver Build submission failed".to_string()),
        })
    }

    /// RSync Builder ì œì¶œ
    async fn try_rsync_builder(&self, tx: &Transaction, _tip: U256) -> Result<PrivateSubmissionResult> {
        let client = reqwest::Client::new();
        let url = "https://rsync-builder.xyz/api/v1/bundle";
        
        let payload = serde_json::json!({
            "transactions": [format!("0x{}", hex::encode(&tx.data))],
            "target_block": tx.block_number.unwrap_or(0)
        });
        
        let response = client
            .post(url)
            .header("Content-Type", "application/json")
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            if let Some(bundle_id) = result.get("bundle_id").and_then(|id| id.as_str()) {
                info!("âœ… RSync Builder ì œì¶œ ì„±ê³µ: {}", bundle_id);
                return Ok(PrivateSubmissionResult {
                    success: true,
                    bundle_hash: Some(bundle_id.to_string()),
                    error: None,
                });
            }
        }
        
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some("RSync Builder submission failed".to_string()),
        })
    }

    /// Titan Builder ì œì¶œ
    async fn try_titan_builder(&self, tx: &Transaction, _tip: U256) -> Result<PrivateSubmissionResult> {
        let client = reqwest::Client::new();
        let url = "https://titan-builder.xyz/api/v1/submit";
        
        let payload = serde_json::json!({
            "txs": [format!("0x{}", hex::encode(&tx.data))],
            "block_number": tx.block_number.unwrap_or(0)
        });
        
        let response = client
            .post(url)
            .header("Content-Type", "application/json")
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            if let Some(bundle_id) = result.get("bundle_id").and_then(|id| id.as_str()) {
                info!("âœ… Titan Builder ì œì¶œ ì„±ê³µ: {}", bundle_id);
                return Ok(PrivateSubmissionResult {
                    success: true,
                    bundle_hash: Some(bundle_id.to_string()),
                    error: None,
                });
            }
        }
        
        Ok(PrivateSubmissionResult {
            success: false,
            bundle_hash: None,
            error: Some("Titan Builder submission failed".to_string()),
        })
    }

    /// Flashbots ì„œëª… ìƒì„±
    fn generate_flashbots_signature(&self, payload: &serde_json::Value) -> String {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ê°œì¸í‚¤ë¡œ ì„œëª…í•´ì•¼ í•¨
        // ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜ìš© ë”ë¯¸ ì„œëª…
        let signature = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
        format!("0x0000000000000000000000000000000000000000000000000000000000000000:{}", signature)
    }
}

/// ê²½ìŸ ë¶„ì„ ê²°ê³¼
#[derive(Debug, Clone)]
struct CompetitionAnalysis {
    mempool_competitors: Vec<MempoolCompetitor>,
    historical_competitors: Vec<HistoricalCompetitor>,
    competition_intensity: CompetitionIntensity,
    analysis_timestamp: chrono::DateTime<chrono::Utc>,
}

/// ë©¤í’€ ê²½ìŸì
#[derive(Debug, Clone)]
struct MempoolCompetitor {
    address: Address,
    gas_price: U256,
    estimated_profit: U256,
    time_to_execution: u64, // ì´ˆ
}

/// ê³¼ê±° ê²½ìŸì
#[derive(Debug, Clone)]
struct HistoricalCompetitor {
    address: Address,
    gas_price: U256,
    success: bool,
    block_number: u64,
    profit_earned: U256,
}

/// ê²½ìŸ ê°•ë„
#[derive(Debug, Clone, PartialEq)]
enum CompetitionIntensity {
    Low,
    Medium,
    High,
    VeryHigh,
}

/// ê°€ìŠ¤ íŠ¸ë Œë“œ ë¶„ì„
#[derive(Debug, Clone)]
struct GasTrendAnalysis {
    trend: GasTrend,
    volatility: f64,
    multiplier: f64,
}

// GasTrendëŠ” ì´ë¯¸ ìœ„ì— ì •ì˜ë˜ì–´ ìˆìŒ (Line 38-42)

/// ê¸°íšŒ ìš°ì„ ìˆœìœ„
#[derive(Debug, Clone, PartialEq)]
enum OpportunityPriority {
    Critical,
    High,
    Medium,
    Low,
}

/// íŒ ì¡°ì •
#[derive(Debug, Clone)]
struct TipAdjustment {
    multiplier: f64,
    reason: String,
}

/// ë¦´ë ˆì´ ì„¤ì •
#[derive(Debug, Clone)]
struct RelayConfig {
    name: String,
    url: String,
    priority: u8,
    timeout_ms: u64,
    max_retries: u8,
    weight: f64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::OpportunityType;
    use tokio;

    fn create_test_config() -> Arc<Config> {
        Arc::new(Config::default())
    }

    fn create_test_blockchain_client() -> Arc<BlockchainClient> {
        Arc::new(BlockchainClient::new_mock())
    }

    fn create_test_executor() -> LiquidationExecutor {
        LiquidationExecutor::new(
            create_test_config(),
            create_test_blockchain_client(),
        )
    }

    fn create_test_opportunity() -> Opportunity {
        Opportunity {
            id: "test_liquidation_001".to_string(),
            opportunity_type: OpportunityType::Liquidation,
            dex: "Aave V3".to_string(),
            token_in: Address::ZERO,
            token_out: Address::ZERO,
            amount_in: U256::from(1000000000000000000u64), // 1 ETH
            expected_profit: U256::from(100000000000000000u64), // 0.1 ETH
            gas_estimate: 300000,
            priority: crate::types::Priority::High,
            confidence_score: 0.95,
            expiry_block: 1000,
            created_at: Utc::now(),
            metadata: serde_json::json!({
                "protocol": "aave_v3",
                "user": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0",
                "collateral_token": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
                "debt_token": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
                "debt_amount": "1000000000", // 1000 USDC
                "health_factor": "0.95"
            }),
        }
    }

    #[test]
    fn test_executor_creation() {
        let executor = create_test_executor();
        assert_eq!(executor.gas_multiplier, 1.2);
    }

    #[test]
    fn test_competition_level_calculation() {
        let executor = create_test_executor();

        // Low profit should result in lower competition
        let low_profit = U256::from(10000000000000000u64); // 0.01 ETH
        let low_comp = executor.calculate_competition_level(low_profit);
        assert!(matches!(low_comp, CompetitionLevel::Low));

        // High profit should result in higher competition
        let high_profit = U256::from(10000000000000000000u64); // 10 ETH
        let high_comp = executor.calculate_competition_level(high_profit);
        assert!(matches!(high_comp, CompetitionLevel::VeryHigh));
    }

    #[test]
    fn test_gas_analysis() {
        let executor = create_test_executor();

        let gas_analysis = GasAnalysis {
            current_gas_price: 50.0,
            is_high_gas: false,
            trend: GasTrend::Stable,
            network_congestion: 0.5,
        };

        assert!(!gas_analysis.is_high_gas);
        assert!(matches!(gas_analysis.trend, GasTrend::Stable));
    }

    #[tokio::test]
    async fn test_dynamic_tip_calculation() {
        let executor = create_test_executor();
        let opportunity = create_test_opportunity();

        let tip = executor.calculate_dynamic_tip(
            &opportunity,
            CompetitionLevel::Medium,
            50.0
        );

        // Tip should be positive and reasonable
        assert!(tip > U256::ZERO);

        // Tip should not exceed expected profit
        assert!(tip < opportunity.expected_profit);
    }

    #[tokio::test]
    async fn test_should_use_private_submission() {
        let executor = create_test_executor();
        let opportunity = create_test_opportunity();

        let gas_analysis = GasAnalysis {
            current_gas_price: 50.0,
            is_high_gas: false,
            trend: GasTrend::Stable,
            network_congestion: 0.5,
        };

        let should_use_private = executor.should_use_private_submission(
            &opportunity,
            CompetitionLevel::High,
            &gas_analysis
        );

        // High competition should trigger private submission
        assert!(should_use_private);
    }

    #[tokio::test]
    async fn test_aave_liquidation_transaction_creation() {
        let executor = create_test_executor();
        let opportunity = create_test_opportunity();

        let result = executor.execute_liquidation_direct(&opportunity, ExecutionMode::Private).await;

        // Should handle mock execution gracefully
        assert!(result.is_ok() || result.is_err()); // Either result is valid in test env
    }

    #[test]
    fn test_protocol_detection() {
        let executor = create_test_executor();

        // Test Aave V3 detection
        let aave_opp = create_test_opportunity();
        assert_eq!(
            aave_opp.metadata.get("protocol").and_then(|v| v.as_str()),
            Some("aave_v3")
        );

        // Test metadata parsing
        let user = aave_opp.metadata.get("user").and_then(|v| v.as_str());
        assert!(user.is_some());

        let health_factor = aave_opp.metadata.get("health_factor").and_then(|v| v.as_str());
        assert!(health_factor.is_some());
    }

    #[test]
    fn test_execution_mode() {
        // Test execution mode variants
        let private_mode = ExecutionMode::Private;
        let public_mode = ExecutionMode::Public;
        let hybrid_mode = ExecutionMode::Hybrid;

        assert!(matches!(private_mode, ExecutionMode::Private));
        assert!(matches!(public_mode, ExecutionMode::Public));
        assert!(matches!(hybrid_mode, ExecutionMode::Hybrid));
    }

    #[tokio::test]
    async fn test_liquidation_profitability() {
        let executor = create_test_executor();
        let opportunity = create_test_opportunity();

        // Calculate expected profit after gas
        let gas_cost = U256::from(opportunity.gas_estimate) * U256::from(50_000_000_000u64); // 50 gwei
        let net_profit = if opportunity.expected_profit > gas_cost {
            opportunity.expected_profit - gas_cost
        } else {
            U256::ZERO
        };

        // Net profit should be positive for valid opportunity
        assert!(net_profit > U256::ZERO);
    }

    #[tokio::test]
    async fn test_private_submission_result() {
        let result = PrivateSubmissionResult {
            success: true,
            tx_hash: Some("0x1234567890abcdef".to_string()),
            relay_name: Some("flashbots".to_string()),
            block_number: Some(1000),
            error: None,
        };

        assert!(result.success);
        assert!(result.tx_hash.is_some());
        assert_eq!(result.relay_name, Some("flashbots".to_string()));
        assert_eq!(result.block_number, Some(1000));
        assert!(result.error.is_none());
    }

    #[test]
    fn test_gas_trend_variants() {
        let rising = GasTrend::Rising;
        let falling = GasTrend::Falling;
        let stable = GasTrend::Stable;

        assert!(matches!(rising, GasTrend::Rising));
        assert!(matches!(falling, GasTrend::Falling));
        assert!(matches!(stable, GasTrend::Stable));
    }

    #[test]
    fn test_competition_level_variants() {
        let low = CompetitionLevel::Low;
        let medium = CompetitionLevel::Medium;
        let high = CompetitionLevel::High;
        let very_high = CompetitionLevel::VeryHigh;

        assert!(matches!(low, CompetitionLevel::Low));
        assert!(matches!(medium, CompetitionLevel::Medium));
        assert!(matches!(high, CompetitionLevel::High));
        assert!(matches!(very_high, CompetitionLevel::VeryHigh));
    }

    #[tokio::test]
    async fn test_multiple_protocol_support() {
        let executor = create_test_executor();

        // Test that executor can handle different protocols
        let protocols = vec!["aave_v3", "compound_v2", "maker"];

        for protocol in protocols {
            let mut opp = create_test_opportunity();
            opp.metadata = serde_json::json!({
                "protocol": protocol,
                "user": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0"
            });

            // Should not panic for any supported protocol
            let protocol_name = opp.metadata.get("protocol").and_then(|v| v.as_str());
            assert_eq!(protocol_name, Some(protocol));
        }
    }

    #[tokio::test]
    async fn test_high_gas_scenario() {
        let executor = create_test_executor();

        let high_gas_analysis = GasAnalysis {
            current_gas_price: 200.0, // Very high gas
            is_high_gas: true,
            trend: GasTrend::Rising,
            network_congestion: 0.9,
        };

        // High gas should influence execution strategy
        assert!(high_gas_analysis.is_high_gas);
        assert!(high_gas_analysis.current_gas_price > 100.0);
        assert!(matches!(high_gas_analysis.trend, GasTrend::Rising));
    }

    #[tokio::test]
    async fn test_tip_calculation_with_different_competition() {
        let executor = create_test_executor();
        let opportunity = create_test_opportunity();

        let low_comp_tip = executor.calculate_dynamic_tip(
            &opportunity,
            CompetitionLevel::Low,
            50.0
        );

        let high_comp_tip = executor.calculate_dynamic_tip(
            &opportunity,
            CompetitionLevel::VeryHigh,
            50.0
        );

        // Higher competition should result in higher tip
        assert!(high_comp_tip > low_comp_tip);
    }
}
