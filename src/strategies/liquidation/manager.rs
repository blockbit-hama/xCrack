use ethers::types::{Address, U256};
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use anyhow::{Result, anyhow};
use tracing::{info, debug, warn, error};
use ethers::providers::{Provider, Ws};
use ethers::middleware::Middleware;
use tokio::time::{interval, Duration};
use tokio::sync::RwLock;

use crate::config::Config;
use crate::protocols::MultiProtocolScanner;
use crate::mev::{MEVBundleExecutor, BundleExecutionResult, ExecutionStats};
use super::{PositionScanner, PositionAnalyzer, types::{LendingProtocolInfo, OnChainLiquidationOpportunity}};

/// ÌÜµÌï© Ï≤≠ÏÇ∞ Í¥ÄÎ¶¨Ïûê - Î™®Îì† Ï≤≠ÏÇ∞ Íµ¨ÏÑ±ÏöîÏÜåÎ•º Ï°∞Ïú®
pub struct IntegratedLiquidationManager {
    config: Arc<Config>,
    provider: Arc<Provider<Ws>>,
    protocol_scanner: Arc<Mutex<MultiProtocolScanner>>,
    position_analyzer: Arc<PositionAnalyzer>,
    bundle_executor: Arc<Mutex<MEVBundleExecutor>>,

    // ÏÉÅÌÉú Í¥ÄÎ¶¨
    is_running: Arc<RwLock<bool>>,
    current_opportunities: Arc<RwLock<Vec<OnChainLiquidationOpportunity>>>,
    execution_history: Arc<RwLock<Vec<BundleExecutionResult>>>,
    performance_metrics: Arc<RwLock<PerformanceMetrics>>,
}

#[derive(Debug, Clone, Default)]
pub struct PerformanceMetrics {
    pub total_opportunities_detected: u64,
    pub opportunities_executed: u64,
    pub total_profit_earned: f64,
    pub total_gas_spent: f64,
    pub average_profit_per_execution: f64,
    pub execution_success_rate: f64,
    pub average_detection_time_ms: f64,
    pub uptime_seconds: u64,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone)]
pub struct LiquidationSummary {
    pub active_opportunities: usize,
    pub pending_executions: usize,
    pub total_potential_profit: f64,
    pub protocol_breakdown: HashMap<String, u32>,
    // pub top_opportunities: Vec<LiquidationOpportunityV2>,
    pub recent_executions: Vec<BundleExecutionResult>,
    pub performance_metrics: PerformanceMetrics,
}

impl IntegratedLiquidationManager {
    pub async fn new(
        config: Arc<Config>,
        provider: Arc<Provider<Ws>>,
    ) -> Result<Self> {
        info!("üè≠ Initializing Integrated Liquidation Manager...");

        // ÌîÑÎ°úÌÜ†ÏΩú Ïä§Ï∫êÎÑà Ï¥àÍ∏∞Ìôî
        let protocol_scanner = Arc::new(Mutex::new(
            MultiProtocolScanner::new(Arc::clone(&config), Arc::clone(&provider)).await?
        ));

        // Ìè¨ÏßÄÏÖò Î∂ÑÏÑùÍ∏∞ Ï¥àÍ∏∞Ìôî
        let min_profit_eth = U256::from(
            (config.liquidation.min_profit_threshold_usd.unwrap_or(100.0) * 1e18 / 2800.0) as u64 // ETH Í∞ÄÍ≤© 2800 USD Í∞ÄÏ†ï
        );
        let health_factor_threshold = 1.0; // Ï≤≠ÏÇ∞ ÏûÑÍ≥ÑÍ∞í
        let position_analyzer = Arc::new(PositionAnalyzer::new(min_profit_eth, health_factor_threshold));

        // MEV Bundle Ïã§ÌñâÏûê Ï¥àÍ∏∞Ìôî
        let bundle_executor = Arc::new(Mutex::new(
            MEVBundleExecutor::new(Arc::clone(&config), Arc::clone(&provider)).await?
        ));

        info!("‚úÖ Integrated Liquidation Manager initialized");

        Ok(Self {
            config,
            provider,
            protocol_scanner,
            position_analyzer,
            bundle_executor,
            is_running: Arc::new(RwLock::new(false)),
            current_opportunities: Arc::new(RwLock::new(Vec::new())),
            execution_history: Arc::new(RwLock::new(Vec::new())),
            performance_metrics: Arc::new(RwLock::new(PerformanceMetrics::default())),
        })
    }
    
    /// ÏûêÎèô Ï≤≠ÏÇ∞ Î¥á ÏãúÏûë
    pub async fn start_automated_liquidation(&self) -> Result<()> {
        let mut is_running = self.is_running.write().await;
        if *is_running {
            warn!("‚ö†Ô∏è Automated liquidation already running");
            return Ok(());
        }
        *is_running = true;
        drop(is_running);
        
        info!("üöÄ Starting automated liquidation bot...");
        
        // Î∞±Í∑∏ÎùºÏö¥Îìú Ïä§Ï∫êÎãù ÏãúÏûë
        self.start_background_scanning().await?;
        
        // Î©îÏù∏ Ïã§Ìñâ Î£®ÌîÑ ÏãúÏûë
        let manager = Arc::new(self.clone());
        tokio::spawn(async move {
            manager.run_execution_loop().await;
        });
        
        info!("‚úÖ Automated liquidation bot started");
        Ok(())
    }
    
    /// ÏûêÎèô Ï≤≠ÏÇ∞ Î¥á Ï§ëÏßÄ
    pub async fn stop_automated_liquidation(&self) -> Result<()> {
        let mut is_running = self.is_running.write().await;
        if !*is_running {
            warn!("‚ö†Ô∏è Automated liquidation not running");
            return Ok(());
        }
        *is_running = false;
        
        // ÌîÑÎ°úÌÜ†ÏΩú Ïä§Ï∫êÎÑà Ï§ëÏßÄ
        self.protocol_scanner.lock().await.stop_background_scanning().await?;
        
        info!("üõë Automated liquidation bot stopped");
        Ok(())
    }
    
    /// Î∞±Í∑∏ÎùºÏö¥Îìú Ïä§Ï∫êÎãù ÏãúÏûë
    async fn start_background_scanning(&self) -> Result<()> {
        self.protocol_scanner.lock().await.start_background_scanning().await
    }
    
    /// Î©îÏù∏ Ïã§Ìñâ Î£®ÌîÑ
    async fn run_execution_loop(&self) {
        let scan_interval = Duration::from_secs(
            self.config.liquidation.scan_interval_seconds.unwrap_or(30)
        );
        let mut interval_timer = interval(scan_interval);
        
        info!("üîÑ Starting execution loop with {:.1}s interval", scan_interval.as_secs_f32());
        
        while *self.is_running.read().await {
            interval_timer.tick().await;
            
            let cycle_start = std::time::Instant::now();
            
            // 1. Í∏∞Ìöå ÌÉêÏßÄ Î∞è Î∂ÑÏÑù
            match self.detect_and_analyze_opportunities().await {
                Ok(opportunities) => {
                    if !opportunities.is_empty() {
                        // 2. Í∏∞Ìöå Ïã§Ìñâ
                        match self.execute_opportunities(opportunities).await {
                            Ok(results) => {
                                self.process_execution_results(results).await;
                            }
                            Err(e) => {
                                error!("‚ùå Execution failed: {}", e);
                            }
                        }
                    }
                }
                Err(e) => {
                    error!("‚ùå Opportunity detection failed: {}", e);
                }
            }
            
            // 3. ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
            self.update_performance_metrics(cycle_start.elapsed()).await;
            
            // 4. ÎßåÎ£åÎêú Bundle Ï†ïÎ¶¨
            self.cleanup_expired_data().await;
        }
        
        info!("üèÅ Execution loop stopped");
    }
    
    /// Í∏∞Ìöå ÌÉêÏßÄ Î∞è Î∂ÑÏÑù
    async fn detect_and_analyze_opportunities(&self) -> Result<Vec<OnChainLiquidationOpportunity>> {
        debug!("üîç Detecting liquidation opportunities...");

        let mut all_opportunities = Vec::new();

        // ÌîÑÎ°úÌÜ†ÏΩú Ïä§Ï∫êÎÑàÏóêÏÑú ÌîÑÎ°úÌÜ†ÏΩú Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        let protocol_summary = self.protocol_scanner.lock().await.get_liquidation_summary().await?;

        // Í∞Å ÌîÑÎ°úÌÜ†ÏΩúÏóê ÎåÄÌï¥ Í≥†ÏúÑÌóò ÏÇ¨Ïö©Ïûê Ï°∞Ìöå Î∞è Î∂ÑÏÑù
        for (protocol_type, protocol_data) in &protocol_summary.protocol_breakdown {
            // Í≥†ÏúÑÌóò ÏÇ¨Ïö©Ïûê Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
            // LendingProtocolInfo ÏÉùÏÑ±
            let protocol_info = crate::strategies::liquidation::types::LendingProtocolInfo {
                protocol_type: match protocol_type {
                    crate::protocols::ProtocolType::Aave => crate::strategies::liquidation::types::ProtocolType::Aave,
                    crate::protocols::ProtocolType::CompoundV2 => crate::strategies::liquidation::types::ProtocolType::Compound,
                    crate::protocols::ProtocolType::MakerDAO => crate::strategies::liquidation::types::ProtocolType::MakerDAO,
                    crate::protocols::ProtocolType::CompoundV3 => crate::strategies::liquidation::types::ProtocolType::Compound,
                },
                lending_pool_address: Address::zero(),
                name: format!("{:?}", protocol_type),
                liquidation_fee: 500, // 5% Í∏∞Î≥∏Í∞í
                min_health_factor: 1.0,
                price_oracle_address: Some(Address::zero()),
                supported_assets: vec![],
            };
            let high_risk_users = self.get_high_risk_users_for_protocol(&protocol_info).await?;

            // Í∞Å ÏÇ¨Ïö©ÏûêÏóê ÎåÄÌï¥ Ìè¨ÏßÄÏÖò Î∂ÑÏÑù
            for user_address in high_risk_users {
                let opportunity = match protocol_type {
                    crate::protocols::ProtocolType::Aave => {
                        // LendingProtocolInfoÎ•º ÏÉùÏÑ±Ìï¥Ïïº Ìï®
                        let protocol_info = crate::strategies::liquidation::types::LendingProtocolInfo {
                            protocol_type: crate::strategies::liquidation::types::ProtocolType::Aave,
                            lending_pool_address: Address::zero(), // Ïã§Ï†ú Ï£ºÏÜåÎ°ú ÍµêÏ≤¥ ÌïÑÏöî
                            name: "Aave".to_string(),
                            liquidation_fee: 500,
                            min_health_factor: 1.0,
                            price_oracle_address: Some(Address::zero()),
                            supported_assets: vec![],
                        };
                        self.position_analyzer.analyze_aave_position(user_address, &protocol_info).await?
                    }
                    crate::protocols::ProtocolType::CompoundV2 => {
                        let protocol_info = crate::strategies::liquidation::types::LendingProtocolInfo {
                            protocol_type: crate::strategies::liquidation::types::ProtocolType::Compound,
                            lending_pool_address: Address::zero(),
                            name: "Compound".to_string(),
                            liquidation_fee: 500,
                            min_health_factor: 1.0,
                            price_oracle_address: Some(Address::zero()),
                            supported_assets: vec![],
                        };
                        self.position_analyzer.analyze_compound_position(user_address, &protocol_info).await?
                    }
                    crate::protocols::ProtocolType::MakerDAO => {
                        let protocol_info = crate::strategies::liquidation::types::LendingProtocolInfo {
                            protocol_type: crate::strategies::liquidation::types::ProtocolType::MakerDAO,
                            lending_pool_address: Address::zero(),
                            name: "MakerDAO".to_string(),
                            liquidation_fee: 500,
                            min_health_factor: 1.0,
                            price_oracle_address: Some(Address::zero()),
                            supported_assets: vec![],
                        };
                        self.position_analyzer.analyze_maker_position(user_address, &protocol_info).await?
                    }
                    crate::protocols::ProtocolType::CompoundV3 => {
                        let protocol_info = crate::strategies::liquidation::types::LendingProtocolInfo {
                            protocol_type: crate::strategies::liquidation::types::ProtocolType::Compound,
                            lending_pool_address: Address::zero(),
                            name: "CompoundV3".to_string(),
                            liquidation_fee: 500,
                            min_health_factor: 1.0,
                            price_oracle_address: Some(Address::zero()),
                            supported_assets: vec![],
                        };
                        self.position_analyzer.analyze_compound_position(user_address, &protocol_info).await?
                    }
                };

                if let Some(opp) = opportunity {
                    all_opportunities.push(opp);
                }
            }
        }

        // ÏàòÏùµÏÑ± ÏàúÏúºÎ°ú Ï†ïÎ†¨
        all_opportunities.sort_by(|a, b| b.net_profit.cmp(&a.net_profit));

        if !all_opportunities.is_empty() {
            info!("üí° Found {} liquidation opportunities", all_opportunities.len());

            // ÌòÑÏû¨ Í∏∞Ìöå ÏóÖÎç∞Ïù¥Ìä∏
            *self.current_opportunities.write().await = all_opportunities.clone();

            // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            let mut metrics = self.performance_metrics.write().await;
            metrics.total_opportunities_detected += all_opportunities.len() as u64;
        }

        Ok(all_opportunities)
    }

    /// ÌäπÏ†ï ÌîÑÎ°úÌÜ†ÏΩúÏùò Í≥†ÏúÑÌóò ÏÇ¨Ïö©Ïûê Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
    async fn get_high_risk_users_for_protocol(&self, _protocol: &LendingProtocolInfo) -> Result<Vec<Address>> {
        // Ïã§Ï†úÎ°úÎäî Îã§Ïùå Î∞©Î≤ïÏúºÎ°ú Í∞ÄÏ†∏ÏôÄÏïº Ìï®:
        // 1. Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ÏóêÏÑú ÏµúÍ∑º Í±∞ÎûòÌïú ÏÇ¨Ïö©ÏûêÎì§
        // 2. ÏÑúÎ∏åÍ∑∏ÎûòÌîÑ API (The Graph)
        // 3. Ïò§ÌîÑÏ≤¥Ïù∏ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú

        // ÌòÑÏû¨Îäî ÏïåÎ†§ÏßÑ ÌÖåÏä§Ìä∏ Ï£ºÏÜåÎì§ Î∞òÌôò
        Ok(vec![
            "0x742d35Cc6570000000000000000000000000001".parse()?,
            "0x742d35Cc6570000000000000000000000000002".parse()?,
            "0x742d35Cc6570000000000000000000000000003".parse()?,
        ])
    }
    
    /// Í∏∞Ìöå Ïã§Ìñâ
    async fn execute_opportunities(&self, opportunities: Vec<OnChainLiquidationOpportunity>) -> Result<Vec<BundleExecutionResult>> {
        info!("‚ö° Executing {} liquidation opportunities", opportunities.len());

        // ÌòÑÏû¨ Î∏îÎ°ù Î≤àÌò∏ Í∞ÄÏ†∏Ïò§Í∏∞
        let current_block = self.provider.get_block_number().await?.as_u64();
        let target_block = current_block + 1;

        // ÏàòÏùµÏÑ± ÏàúÏúºÎ°ú Ï†ïÎ†¨ÌïòÍ≥† ÎèôÏãú Ïã§Ìñâ Ï†úÌïú Ï†ÅÏö©
        let max_concurrent = self.config.liquidation.max_concurrent_liquidations as usize;
        let top_opportunities: Vec<OnChainLiquidationOpportunity> = opportunities.into_iter()
            .take(max_concurrent)
            .collect();

        info!("üìä Executing top {} opportunities at target block {}", top_opportunities.len(), target_block);

        // Í∞Å Í∏∞ÌöåÎ•º BundleÎ°ú Î≥ÄÌôòÌïòÏó¨ Ïã§Ìñâ
        let mut results = Vec::new();
        for opp in top_opportunities {
            // Ï≤≠ÏÇ∞ Bundle ÏÉùÏÑ± Î∞è Ïã§Ìñâ
            match self.execute_single_liquidation(opp, target_block).await {
                Ok(result) => results.push(result),
                Err(e) => {
                    warn!("Ï≤≠ÏÇ∞ Ïã§Ìñâ Ïã§Ìå®: {}", e);
                }
            }
        }

        Ok(results)
    }

    /// Îã®Ïùº Ï≤≠ÏÇ∞ Ïã§Ìñâ
    async fn execute_single_liquidation(
        &self,
        opportunity: OnChainLiquidationOpportunity,
        target_block: u64,
    ) -> Result<BundleExecutionResult> {
        debug!("üí∏ Executing liquidation for user {} on protocol {}",
            opportunity.target_user, opportunity.protocol.name);

        // Ïã§Ï†úÎ°úÎäî bundle_executorÎ•º ÌÜµÌï¥ Ï≤≠ÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìñâ
        // ÌòÑÏû¨Îäî Í∞ÑÎã®Ìïú ÏãúÎÆ¨Î†àÏù¥ÏÖò Í≤∞Í≥º Î∞òÌôò
        let success = opportunity.success_probability > 0.5;
        let profit_realized = if success {
            Some((opportunity.net_profit.as_u128() as f64) / 1e18)
        } else {
            None
        };

        Ok(BundleExecutionResult {
            bundle_id: format!("liq_{:?}_{}", opportunity.target_user, target_block),
            success,
            transaction_hash: if success { Some(ethers::types::H256::random()) } else { None },
            execution_time_ms: 100, // ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏãúÍ∞Ñ
            profit_realized,
            gas_used: Some((opportunity.gas_cost.as_u128() as f64 / 1e18) as u64),
            error_message: if !success { Some("Simulation failed".to_string()) } else { None },
            block_number: Some(target_block),
        })
    }
    
    /// Ïã§Ìñâ Í≤∞Í≥º Ï≤òÎ¶¨
    async fn process_execution_results(&self, results: Vec<BundleExecutionResult>) {
        debug!("üìä Processing {} execution results", results.len());
        
        let mut total_profit = 0.0;
        let mut successful_executions = 0;
        
        for result in &results {
            if result.success {
                successful_executions += 1;
                if let Some(profit) = result.profit_realized {
                    total_profit += profit;
                }
                
                info!("‚úÖ Liquidation successful: {} (${:.2} profit)", 
                      result.bundle_id, result.profit_realized.unwrap_or(0.0));
            } else {
                warn!("‚ùå Liquidation failed: {} - {}", 
                      result.bundle_id, result.error_message.as_deref().unwrap_or("Unknown error"));
            }
        }
        
        // Ïã§Ìñâ Í∏∞Î°ù ÏóÖÎç∞Ïù¥Ìä∏
        let mut history = self.execution_history.write().await;
        history.extend(results);
        
        // ÏµúÍ∑º 100Í∞úÎßå Ïú†ÏßÄ
        let current_len = history.len();
        if current_len > 100 {
            history.drain(0..current_len - 100);
        }
        
        // Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
        let mut metrics = self.performance_metrics.write().await;
        metrics.opportunities_executed += successful_executions;
        metrics.total_profit_earned += total_profit;
        
        if metrics.opportunities_executed > 0 {
            metrics.average_profit_per_execution = metrics.total_profit_earned / metrics.opportunities_executed as f64;
            metrics.execution_success_rate = (metrics.opportunities_executed as f64) / (metrics.total_opportunities_detected as f64);
        }
        
        metrics.last_updated = chrono::Utc::now();
        
        info!("üí∞ Execution cycle complete: {} successful, ${:.2} total profit", 
              successful_executions, total_profit);
    }
    
    /// ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
    async fn update_performance_metrics(&self, cycle_duration: std::time::Duration) {
        let mut metrics = self.performance_metrics.write().await;
        
        // ÌèâÍ∑† ÌÉêÏßÄ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
        let cycle_ms = cycle_duration.as_millis() as f64;
        if metrics.total_opportunities_detected > 0 {
            let total_cycles = metrics.total_opportunities_detected as f64;
            metrics.average_detection_time_ms = 
                (metrics.average_detection_time_ms * (total_cycles - 1.0) + cycle_ms) / total_cycles;
        } else {
            metrics.average_detection_time_ms = cycle_ms;
        }
        
        metrics.uptime_seconds += cycle_duration.as_secs();
    }
    
    /// ÎßåÎ£åÎêú Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
    async fn cleanup_expired_data(&self) {
        // Bundle Ï†ïÎ¶¨
        let cleaned_bundles = self.bundle_executor.lock().await.cleanup_expired_bundles().await;
        if cleaned_bundles > 0 {
            debug!("üßπ Cleaned up {} expired bundles", cleaned_bundles);
        }

        // Í∏∞Ìöå Ï†ïÎ¶¨ (5Î∂Ñ Ïù¥ÏÉÅ Îêú Í≤ÉÎì§)
        let mut opportunities = self.current_opportunities.write().await;
        let initial_count = opportunities.len();

        // 5Î∂Ñ Ïù¥ÏÉÅ ÏßÄÎÇú Í∏∞ÌöåÎì§ Ï†úÍ±∞
        opportunities.retain(|opp| {
            let age = opp.position.last_updated.elapsed().as_secs();
            age < 300 // 5Î∂Ñ = 300Ï¥à
        });

        if opportunities.len() != initial_count {
            debug!("üßπ Cleaned up {} expired opportunities", initial_count - opportunities.len());
        }
    }
    
    /// ÌäπÏ†ï ÏÇ¨Ïö©Ïûê Ï≤≠ÏÇ∞ ÏãúÎèÑ
    pub async fn liquidate_user(&self, user_address: Address) -> Result<BundleExecutionResult> {
        info!("üéØ Attempting to liquidate user: {}", user_address);

        // ÌîÑÎ°úÌÜ†ÏΩú Ïä§Ï∫êÎÑàÏóêÏÑú ÌîÑÎ°úÌÜ†ÏΩú Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        let protocol_summary = self.protocol_scanner.lock().await.get_liquidation_summary().await?;

        // Î™®Îì† ÌîÑÎ°úÌÜ†ÏΩúÏóêÏÑú Ìï¥Îãπ ÏÇ¨Ïö©Ïûê Î∂ÑÏÑù
        for (protocol_type, protocol_data) in &protocol_summary.protocol_breakdown {
            // LendingProtocolInfo ÏÉùÏÑ±
            let protocol_info = crate::strategies::liquidation::types::LendingProtocolInfo {
                protocol_type: match protocol_type {
                    crate::protocols::ProtocolType::Aave => crate::strategies::liquidation::types::ProtocolType::Aave,
                    crate::protocols::ProtocolType::CompoundV2 => crate::strategies::liquidation::types::ProtocolType::Compound,
                    crate::protocols::ProtocolType::MakerDAO => crate::strategies::liquidation::types::ProtocolType::MakerDAO,
                    crate::protocols::ProtocolType::CompoundV3 => crate::strategies::liquidation::types::ProtocolType::Compound,
                },
                lending_pool_address: Address::zero(),
                name: format!("{:?}", protocol_type),
                liquidation_fee: 500,
                min_health_factor: 1.0,
                price_oracle_address: Some(Address::zero()),
                supported_assets: vec![],
            };
            
            let opportunity = match protocol_type {
                crate::protocols::ProtocolType::Aave => {
                    self.position_analyzer.analyze_aave_position(user_address, &protocol_info).await?
                }
                crate::protocols::ProtocolType::CompoundV2 | crate::protocols::ProtocolType::CompoundV3 => {
                    self.position_analyzer.analyze_compound_position(user_address, &protocol_info).await?
                }
                crate::protocols::ProtocolType::MakerDAO => {
                    self.position_analyzer.analyze_maker_position(user_address, &protocol_info).await?
                }
            };

            if let Some(opp) = opportunity {
                info!("üí∞ Found liquidation opportunity for {}: ${:.2} profit",
                      user_address, (opp.net_profit.as_u128() as f64) / 1e18);

                // ÌòÑÏû¨ Î∏îÎ°ù Î≤àÌò∏ Í∞ÄÏ†∏Ïò§Í∏∞
                let current_block = self.provider.get_block_number().await?.as_u64();

                // Ï≤≠ÏÇ∞ Ïã§Ìñâ
                let result = self.execute_single_liquidation(opp, current_block + 1).await?;

                // Í≤∞Í≥ºÎ•º Ïã§Ìñâ Í∏∞Î°ùÏóê Ï∂îÍ∞Ä
                self.execution_history.write().await.push(result.clone());

                return Ok(result);
            }
        }

        Err(anyhow!("No liquidation opportunity found for user {}", user_address))
    }
    
    /// ÌòÑÏû¨ ÏÉÅÌÉú ÏöîÏïΩ
    pub async fn get_liquidation_summary(&self) -> LiquidationSummary {
        let opportunities = self.current_opportunities.read().await;
        let execution_history = self.execution_history.read().await;
        let metrics = self.performance_metrics.read().await.clone();

        let pending_executions = self.bundle_executor.lock().await.get_pending_bundle_count().await;

        // Ï¥ù Ïû†Ïû¨ ÏàòÏùµ Í≥ÑÏÇ∞
        let total_potential_profit: f64 = opportunities.iter()
            .map(|opp| (opp.net_profit.as_u128() as f64) / 1e18)
            .sum();

        // ÌîÑÎ°úÌÜ†ÏΩúÎ≥Ñ Î∂ÑÎ•ò
        let mut protocol_breakdown = HashMap::new();
        for opp in opportunities.iter() {
            let protocol_name = opp.protocol.name.clone();
            *protocol_breakdown.entry(protocol_name).or_insert(0) += 1;
        }

        let recent_executions = execution_history.iter()
            .rev()
            .take(20)
            .cloned()
            .collect();

        LiquidationSummary {
            active_opportunities: opportunities.len(),
            pending_executions,
            total_potential_profit,
            protocol_breakdown,
            recent_executions,
            performance_metrics: metrics,
        }
    }
    
    /// Ïã§Ìñâ ÌÜµÍ≥Ñ Ï°∞Ìöå
    pub async fn get_execution_stats(&self) -> ExecutionStats {
        self.bundle_executor.lock().await.get_execution_stats().await
    }
    
    /// Ï†ÑÎûµ ÌÜµÍ≥Ñ Ï°∞Ìöå
    pub async fn get_strategy_stats(&self) -> Result<PerformanceMetrics> {
        let metrics = self.performance_metrics.read().await.clone();
        Ok(metrics)
    }
    
    /// ÌîÑÎ°úÌÜ†ÏΩú ÏöîÏïΩ Ï°∞Ìöå
    pub async fn get_protocol_summary(&self) -> Result<crate::protocols::LiquidationSummary> {
        self.protocol_scanner.lock().await.get_liquidation_summary().await
    }
    
    /// Î¥á Ïã§Ìñâ ÏÉÅÌÉú ÌôïÏù∏
    pub async fn is_running(&self) -> bool {
        *self.is_running.read().await
    }
}

impl Clone for IntegratedLiquidationManager {
    fn clone(&self) -> Self {
        Self {
            config: Arc::clone(&self.config),
            provider: Arc::clone(&self.provider),
            protocol_scanner: Arc::clone(&self.protocol_scanner),
            position_analyzer: Arc::clone(&self.position_analyzer),
            bundle_executor: Arc::clone(&self.bundle_executor),
            is_running: Arc::clone(&self.is_running),
            current_opportunities: Arc::clone(&self.current_opportunities),
            execution_history: Arc::clone(&self.execution_history),
            performance_metrics: Arc::clone(&self.performance_metrics),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::Config;
    
    #[tokio::test]
    async fn test_liquidation_manager_initialization() {
        // ÌÖåÏä§Ìä∏Îäî Ïã§Ï†ú ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞Ïù¥ ÌïÑÏöîÌïòÎØÄÎ°ú mock ÌôòÍ≤ΩÏóêÏÑú Ïã§Ìñâ
        println!("Integrated Liquidation Manager tests require live network connection");
    }
    
    #[test]
    fn test_performance_metrics_calculation() {
        let mut metrics = PerformanceMetrics::default();
        
        // Í∏∞Ìöå ÌÉêÏßÄ
        metrics.total_opportunities_detected = 100;
        metrics.opportunities_executed = 85;
        metrics.total_profit_earned = 1250.0;
        
        // Í≥ÑÏÇ∞
        metrics.average_profit_per_execution = metrics.total_profit_earned / metrics.opportunities_executed as f64;
        metrics.execution_success_rate = (metrics.opportunities_executed as f64) / (metrics.total_opportunities_detected as f64);
        
        assert!((metrics.average_profit_per_execution - 14.71).abs() < 0.01);
        assert!((metrics.execution_success_rate - 0.85).abs() < 0.01);
        
        println!("Performance metrics: {:#?}", metrics);
    }
}