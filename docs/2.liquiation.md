## 2. Liquidation Strategy (온체인 청산)

### 구현 현황 요약
- 구현됨
  - Aave/Compound/MakerDAO 실데이터 스캔(간소화) 및 포지션 분석
  - 플래시론 3-스텝 번들: flashLoanSimple → 청산 → (선택) DEX 매도 → 상환(minOut 반영)
  - 0x/1inch 견적 연동 및 비-플래시론 경로에서 approve/SELL 백업 라우팅
  - 동적 가스 전략(긴급도/경쟁도 기반 가중) 적용
  - 설정에서 flashloan receiver 주소 주입, Aave V3 Pool 타깃 일관화
  - FlashLoan 리시버 컨트랙트 및 Foundry 배포/시뮬 스크립트
- 미구현/강화 필요
  - Aave 포지션 스캐너(현재 Compound/Maker 중심), 프로토콜 전 범위 사용자 스캔 확장
  - MakerDAO ilk 전수 스캔과 위험도 순위화(현재 대표 ilk 목록 기반)
  - 더 정교한 건강도/청산 금액 산출(수수료, 변동성, 정밀 환산)
  - 가스 워 모델 고도화: 재시도/백업 번들, 곡선 기반 입찰
  - DEX 다중 라우팅/슬리피지/MEV 보호(현재 0x/1inch 1차통합)
  - 영속 스토리지 스키마와 대시보드/쿼리 API

---

### 구현 코드 인용

#### 1) 플래시론 번들 생성(리시버 파라미터 포함, Aave V3 flashLoanSimple)
```1166:1206:src/strategies/liquidation_onchain.rs
                // 플래시론 수수료(9bps)만큼 상환에 필요한 최소 아웃 계산
                let min_out = {
                    let fee = debt_amount * U256::from(9u64) / U256::from(10000u64);
                    debt_amount + fee
                };
                let params = abi.encode_flashloan_receiver_liquidation_params(
                    to_addr,
                    alloy::primitives::Bytes::from(data_bytes.clone().to_vec()),
                    sell_target.unwrap_or(Address::ZERO),
                    sell_calldata.clone().unwrap_or_else(|| alloy::primitives::Bytes::from(Vec::new())),
                    sell_spender.unwrap_or(Address::ZERO),
                    debt_asset,
                    debt_amount,
                    collateral_asset,
                    min_out,
                )?;
                let flash_calldata = abi.encode_aave_flashloan_simple(
                    receiver_addr,
                    debt_asset,
                    debt_amount,
                    params,
                    0u16,
                )?;
                // Aave V3 Pool 주소 선택
                let aave_pool_addr = if protocol_info.name.to_lowercase().contains("aave") {
                    protocol_info.lending_pool_address
                } else {
                    crate::utils::abi::contracts::AAVE_V3_POOL.clone()
                };
                let flashloan_tx = Transaction { to: Some(aave_pool_addr), .. }
```

#### 2) 0x allowanceTarget 승인 + SELL 백업 라우팅(비-플래시론 경로)
```1259:1271:src/strategies/liquidation_onchain.rs
                    if let Some(spender) = sell_spender {
                        let approve_sell_calldata = abi.encode_erc20_approve(spender, U256::from(u128::MAX))?;
                        let approve_sell_tx = Transaction {
                            to: Some(collateral_asset),
                            data: approve_sell_calldata.to_vec(),
                            ..
                        };
                        txs.push(approve_sell_tx);
                    }
```

#### 3) Compound 포지션 분석(실데이터 기반, 담보 선택 최적화)
```470:507:src/strategies/liquidation_onchain.rs
        // 청산 가능한 금액 산출
        let mut liquidation_amount = borrow_base; ...
        // 부채자산: 설정 USDC 우선
        let debt_asset: Address = if let Some(h160) = self.config.get_token_address("USDC") { ... };
        // 담보 후보 전수 견적 후 최적 담보 선택
        let mut best_collateral: Option<(Address, U256)> = None;
        for asset in protocol.supported_assets.iter() {
            let quoted_e = comet.quote_collateral(H160::from_slice(asset.as_slice()), ...).await.unwrap_or_default();
            let amt = U256::from_str_radix(&quoted_e.to_string(), 10).unwrap_or(U256::ZERO);
            match best_collateral { Some((_a, best)) if best >= amt => {}, _ => best_collateral = Some((*asset, amt)) }
        }
```

#### 4) MakerDAO 포지션 분석(Vat.urns/ilks, ETH-A/B/C 및 WBTC-A)
```568:579:src/strategies/liquidation_onchain.rs
        // 스캔할 대표 ilk 목록과 담보 토큰 주소 (설정 우선, 폴백)
        let weth_address = ...; let wbtc_address = ...; let dai_address = ...;
        let candidates: Vec<(&[u8], Address)> = vec![ (b"ETH-A",weth_address), (b"ETH-B",weth_address), (b"ETH-C",weth_address), (b"WBTC-A",wbtc_address) ];
```

#### 5) MakerDAO Vat 래퍼(urns/ilks 읽기)
```188:217:src/blockchain/contracts.rs
pub struct VatContract { ... }
impl VatContract {
    pub async fn urns(&self, ilk: [u8;32], urn: Address) -> Result<(U256, U256)> { ... }
    pub async fn ilks(&self, ilk: [u8;32]) -> Result<(U256, U256, U256, U256, U256)> { ... }
}
```

#### 6) ABI 인코더(리시버 파라미터/flashLoanSimple)
```12:26:src/utils/abi.rs
interface IFlashLoanReceiverHelper { function executeLiquidation(...); }
```
```347:364:src/utils/abi.rs
pub fn encode_aave_flashloan_simple(...)
```
```395:419:src/utils/abi.rs
pub fn encode_flashloan_receiver_liquidation_params(...)
```

#### 7) FlashLoan 리시버 컨트랙트
```1:200:contracts/FlashLoanLiquidationReceiver.sol
contract FlashLoanLiquidationReceiver { ... executeOperation(...) { ... minOut ... approve ... repay ... } }
```

#### 8) Foundry 배포/시뮬 스크립트
```1:42:foundry.toml
[profile.default] src='contracts' out='out' libs=['lib']
```
```1:42:script/DeployReceiver.s.sol
contract DeployReceiver is Script { ... create receiver with (pool, owner) }
```
```1:111:script/SimulateReceiver.s.sol
contract SimulateReceiver is Script { deploy mock tokens, mint, build params, call executeOperation }
```

---

### 미구현/보완 계획
- 프로토콜 전수 스캔/인덱싱 및 경쟁도 기반 우선순위 큐 통합
- 전 경로 시뮬레이션 + 리그레션 테스트 셋 구축
- DEX 라우팅 고도화(멀티홉, 슬리피지 바운드, MEV 보호)
- 가스 워 재시도/백업 번들, 곡선 기반 동적 입찰
- 스토리지 스키마(포지션/가격/이벤트/경쟁자)와 조회 API 확장
