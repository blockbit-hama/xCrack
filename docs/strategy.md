## MEV 전략 개요 (샌드위치, 청산, 마이크로 아비트래지, 크로스체인 아비트래지)

이 문서는 4가지 전략을 “고등학생에게 설명하듯” 쉽게 풀어 씁니다. 각 전략마다 6단계를 같은 틀로 설명합니다.
1) 데이터 소스 2) 데이터 가져와서 처리하기 3) 처리된 데이터 저장하기 4) 그 데이터로 전략 세우기 5) 전략 결과를 실제로 실행하기 6) 실행 결과 관리하기

쉬운 비유: 블록체인을 “거대한 오픈 장터”라고 하면, 우리는 장터의 소식(데이터)을 듣고, 장부(저장소)에 정리한 뒤, 누구보다 빠르고 똑똑하게 사고팔아 수익을 냅니다. 다만 항상 수수료(가스/수수료)와 위험(가격 변동/실패)을 고려해야 합니다.

참고 주요 경로(일부):
- 샌드위치: `src/strategies/sandwich_onchain.rs`, `src/blockchain/*`, `src/mempool/*`
- 청산: `src/strategies/liquidation_onchain.rs`, `src/utils/abi.rs`, `contracts/FlashLoanLiquidationReceiver.sol`
- 마이크로 아비트: `src/strategies/micro_arbitrage.rs`, `src/exchange/*`
- 크로스체인 아비트: `src/strategies/cross_chain_arbitrage.rs`, `src/bridges/*`
- 공통: `src/core/*`, `src/types.rs`, `src/storage/*`, `config/default.toml`

용어 미니 사전:
- “가스비”: 트랜잭션을 블록에 넣기 위한 수수료. 붐비면 비쌈.
- “번들”: 여러 트랜잭션을 묶어 한 번에 제출하는 것(주로 Flashbots 경로).
- “오라클”: “현재 가격은 얼마” 같은 사실을 알려주는 서비스.
- “브리지”: 체인 A의 자산을 체인 B로 옮기는 길.

---

### 1) 샌드위치 (On-chain Sandwich)
- 데이터 소스
  - Mempool: 아직 블록에 포함되지 않은 “곧 일어날” 스왑 트랜잭션을 관찰합니다. 대개 큰 금액일수록 기회가 커집니다. 사용 경로: `src/mempool/*`.
  - DEX 풀 상태/이벤트: 유동성이 적은 풀일수록 가격이 크게 움직입니다. 사용 경로: `src/blockchain/contracts.rs`, `events.rs`.
  - 가스/네트워크: 혼잡한 시간에는 수수료를 더 내야 앞자리를 차지할 수 있습니다. 참고: `src/blockchain/rpc.rs`.
- 데이터 가져와서 처리하기
  - 1) “스왑 의심” 트랜잭션만 고릅니다(시그니처/토큰 주소 매칭).
  - 2) 예상 가격 이동(슬리피지)을 거칠게 계산합니다. 큰 스왑이면 가격이 크게 흔들립니다.
  - 3) 우리가 앞/뒤에 낄 때의 수익−가스비를 빠르게 추정합니다.
- 저장하기
  - 현재는 메모리 중심(짧게 들고 바로 판단). 향후 `src/storage/*`로 영속 저장(기회, 실패 원인, 성능 통계) 확대 예정.
- 전략 세우기
  - 규칙: “예상 이익 − (가스+위험 프리미엄) > 0”이면 후보. 피해자 보호·규정 준수 등 윤리·규제도 고려합니다.
  - 가스 전략: 경쟁 강도(동일 타깃을 노리는 봇 수 추정)에 따라 우선수수료를 올릴 수 있습니다.
- 실행하기
  - 번들을 구성해 Flashbots로 제출합니다. 앞 트랜잭션으로 가격 올리고, 피해자 스왑이 체결되면 뒤에서 되파는 구조. 현재 라우팅/백업번들은 기본형, 강화 예정.
- 결과 관리하기
  - 성공·실패, 실제 이익, 소요 가스, 경쟁에서 이긴 비율 등을 모읍니다(`src/core/performance_tracker.rs`). 실패 패턴을 학습해 가스곡선/필터를 조정합니다.

안전/리스크 메모: 샌드위치는 규제/윤리 이슈 논쟁이 있습니다. 네트워크 정책 변화를 주기적으로 확인하고, 법적 리스크를 피해야 합니다.

---

### 2) 청산 (On-chain Liquidation)
- 데이터 소스
  - 대출 프로토콜 상태: Aave/Compound/MakerDAO의 담보·부채 정보.
  - 가격/오라클: Chainlink, Uniswap V3 TWAP 등을 상황에 따라 사용.
  - DEX 견적: 0x/1inch로 담보 매도 시 최적 경로 확인(백업 포함).
  - 네트워크/가스: 급할수록 가스비를 더 써서 먼저 집행해야 합니다.
- 데이터 가져와서 처리하기
  - Compound: `borrowBalanceOf/quoteCollateral`로 부채와 담보 환산가치를 산출, 여러 담보 후보 중 최대로 회수되는 조합을 고릅니다.
  - Maker: `Vat.urns/ilks`에서 `ink/art/rate/spot`를 읽어 건강도(담보가치/부채)를 계산합니다. 저하된 포지션을 찾습니다.
  - 동적 가스전략: “긴급도(곧 청산 가능?)”와 “경쟁도(상대 봇 많음?)”를 섞어 우선수수료를 조정합니다.
- 저장하기
  - 당장은 메모리 위주. 곧 `storage`에 포지션 스냅샷, 가격 히스토리, 경쟁자 프로파일, 청산 이벤트를 보관하도록 확장합니다.
- 전략 세우기
  - 원칙: 보상 − (가스 + 플래시론 수수료) > 0. 청산 금액을 너무 크게 잡으면 실패·슬리피지 위험이 커질 수 있어 적절히 제한합니다.
  - 경로 선택: 플래시론(3-스텝) vs 단순 경로(승인→청산→매도). 0x는 `allowanceTarget` 승인 필요 가능.
- 실행하기
  - 플래시론 경로: Aave V3 `flashLoanSimple` 1개 트랜잭션에 모든 스텝을 압축. 리시버 파라미터에 `minOut=원금+9bps`를 넣어 상환 안전장치.
  - 리시버 컨트랙트: `contracts/FlashLoanLiquidationReceiver.sol`이 청산→필요 시 매도→상환을 처리.
  - 비-플래시론 경로: `approve(부채토큰)`→`liquidation`→(옵션)`sell` 번들을 구성, 0x 경로면 담보 토큰도 `allowanceTarget`에 승인.
  - 구현 참고: `src/strategies/liquidation_onchain.rs`, `src/utils/abi.rs`, Foundry 스크립트(`script/DeployReceiver.s.sol`, `script/SimulateReceiver.s.sol`).
- 결과 관리하기
  - “얼마 벌었나 − 가스/수수료?”를 집계하고, 실패 원인을 기록(가격 급변, 경쟁 패배, 승인 누락 등). 데이터는 차후 재학습에 사용.

안전/리스크 메모: 플래시론은 상환이 한 틱이라도 부족하면 전체 롤백됩니다. `minOut` 체크와 DEX 슬리피지 한도를 반드시 설정해야 합니다.

---

### 3) 마이크로 아비트래지 (CEX/DEX/DEX-DEX 소규모 가격차)
- 데이터 소스
  - DEX/CEX 시세·오더북·체결 피드(`src/exchange/*`). 초반에는 모의 데이터/인터페이스로 시작할 수 있습니다.
  - 모니터링/스케줄러: 정해진 주기로 심볼을 스캔하고, 기회 점수를 계산합니다.
- 데이터 가져와서 처리하기
  - 각 거래쌍에 대해 “현재 스프레드 − (수수료+예상 슬리피지+가스)”를 계산합니다.
  - 네트워크/거래소 지연(왕복 시간)을 고려해 실현 가능성을 평가합니다. 지연이 크면 가격이 바뀌어 기회가 사라집니다.
- 저장하기
  - 실행 로그, 평균 체결 시간, 성공률을 메모리에 보관하고 점차 영속 저장(예: Redis)으로 확장합니다.
- 전략 세우기
  - 수익이 양수인 경우만 소량 다회전으로 접근(리스크 분산). 주문 크기는 슬리피지와 체결 가능성을 고려해 보수적으로.
- 실행하기
  - 현재는 모의 실행기(`src/exchange/order_executor.rs`) 경로. 실제 거래소 API(키 관리/레이트리밋/리트라이)는 단계적 도입.
- 결과 관리하기
  - 종합 성과(승률·평균 수익·표준편차)를 추적하고, 심볼별·시간대별 성과를 시각화할 수 있도록 구조화합니다.

안전/리스크 메모: 수수료가 생각보다 커서 “한 번에 크게”보다는 “작게 여러 번”이 안전한 경우가 많습니다. 슬리피지 한도를 항상 설정하세요.

---

### 4) 크로스체인 아비트래지
- 데이터 소스
  - 브리지 견적/성능: LiFi, Stargate, Hop, Rubic, Synapse, Across, Multichain 등(`src/bridges/*`).
  - 체인별 가스비, 예상 체결 시간, 과거 성공률(내부 성능 트래커).
  - 원천/목적지 체인의 DEX 시세(필요 시 양쪽에서 환전 경로 포함).
- 데이터 가져와서 처리하기
  - `CrossChainArbitrageStrategy.scan_real_bridge_opportunities`에서 토큰·체인쌍을 조합해 견적을 모읍니다.
  - 순이익 추정: “목적지에서 실제 손에 쥘 금액 − (원천에서 준비 비용 + 두 체인의 가스비 + 브리지 수수료)”.
  - 시간 리스크: 빠른 브리지일수록 유리. 지연이 길면 가격이 바뀌어 이익이 사라질 수 있습니다.
- 저장하기
  - 현재는 메모리/간단 구조. 곧 브리지 성능 DB(체인×토큰×브리지별 평균 시간, 실패율, 스프레드)를 영속화하여 라우팅에 반영합니다.
- 전략 세우기
  - 라우팅 정책: “최저비용”, “속도-비용 균형”, “성공률 우선” 등 프로파일을 설정하고 상황에 맞게 선택합니다.
  - 견적 만료/재견적: 브리지 견적은 유효 시간이 짧습니다. 실행 직전에 재검증합니다.
- 실행하기
  - `bridge_manager.execute_bridge`로 라우팅된 경로를 호출합니다(초안). 실패 시 백업 경로로 즉시 전환하는 재시도 로직을 마련합니다.
  - 필요하면 출발/도착 체인에서 DEX 교환을 함께 실행(예: ETH→USDC로 바꿔 이동, 도착 후 다시 ETH로).
- 결과 관리하기
  - 체인·브리지별 성과(수익·시간·성공률)를 집계하고, 히스토리를 이용해 다음번 라우팅 점수에 반영합니다.

안전/리스크 메모: 브리지 실패·지연·중단 이슈에 대비해 “최소 보장 금액”과 타임아웃, 재시작 정책을 둡니다. 체인 재조직(reorg)이나 수수료 급등도 대비합니다.

---

### 공통 운영 가이드
- 가스 전략(“얼마나 공격적으로 낼까”)
  - 경쟁이 치열할수록 우선수수료를 올리되, 한계치를 정합니다. 지갑 잔고·1건당 최대 가스비 예산을 명시합니다.
- 슬리피지/가격 보호
  - 모든 스왑·매도에 허용 가능한 최대 슬리피지를 설정합니다. 예상 대비 결과가 나쁘면 자동 철회합니다.
- 번들/백업 라우팅
  - 1차 번들이 실패하면 즉시 2차 번들을 시도하는 구조를 둡니다(특히 샌드위치/청산).
- 관측/알림
  - 실패·지연·이상치(예: 수익 음수)를 즉시 알림하고, 로그로 재현 가능하게 남깁니다.

### 저장소 설계(간단 청사진)
- 단기: 메모리 캐시 + 파일 로그.
- 중기: Redis에 키 체계 예시
  - `pos:{protocol}:{user}`: 포지션 스냅샷
  - `price:{symbol}`: 최근 가격 샘플 시계열
  - `liq:events:{date}`: 청산 성공/실패 이벤트
  - `mev:competitors`: 경쟁자 주소/가스 성향 요약
  - `bridge:perf:{route}`: 브리지 경로 성능 통계
- 장기: 조회 API와 대시보드, 알림 연동(슬랙/텔레그램 등).

### 테스트/시뮬레이션
- 로컬 체인(Anvil)과 Foundry 스크립트로 “가상의 상황”을 여러 번 재연합니다.
- 청산 플래시론은 `script/SimulateReceiver.s.sol`로 최소 동작을 검증합니다.
- 회귀 테스트로 전략 변경이 성과를 해치지 않는지 확인합니다.

### 다음 단계(로드맵 요약)
- 데이터: 더 많은 체인/프로토콜/브리지를 커버, 캐싱·레이트리밋·백오프 정교화.
- 실행: 가스 워 모델 고도화, 번들 백업/재시도, MEV 보호 라우팅(프라이빗 메모풀 등).
- 저장/관측: Redis 스키마 고도화, 리포트/알림 자동화, 실패 원인 분석 파이프라인.
- 안전: 슬리피지·최소수령액·타임아웃 기본값 상향, 키/권한 관리 표준화.
