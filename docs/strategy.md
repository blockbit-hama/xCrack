## MEV 전략 개요 (샌드위치, 청산, 마이크로 아비트래지, 크로스체인 아비트래지)

이 문서는 4가지 전략을 “고등학생에게 설명하듯” 쉽게 풀어 씁니다. 각 전략마다 6단계를 같은 틀로 설명합니다.
1) 데이터 소스 2) 데이터 가져와서 처리하기 3) 처리된 데이터 저장하기 4) 그 데이터로 전략 세우기 5) 전략 결과를 실제로 실행하기 6) 실행 결과 관리하기

쉬운 비유: 블록체인을 “거대한 오픈 장터”라고 하면, 우리는 장터의 소식(데이터)을 듣고, 장부(저장소)에 정리한 뒤, 누구보다 빠르고 똑똑하게 사고팔아 수익을 냅니다. 다만 항상 수수료(가스/수수료)와 위험(가격 변동/실패)을 고려해야 합니다.

참고 주요 경로(일부):
- 샌드위치: `src/strategies/sandwich_onchain.rs`, `src/blockchain/*`, `src/mempool/*`
- 청산: `src/strategies/liquidation_onchain.rs`, `src/utils/abi.rs`, `contracts/FlashLoanLiquidationReceiver.sol`
- 마이크로 아비트: `src/strategies/micro_arbitrage.rs`, `src/exchange/*`
- 크로스체인 아비트: `src/strategies/cross_chain_arbitrage.rs`, `src/bridges/*`
- 공통: `src/core/*`, `src/types.rs`, `src/storage/*`, `config/default.toml`

용어 미니 사전:
- “가스비”: 트랜잭션을 블록에 넣기 위한 수수료. 붐비면 비쌈.
- “번들”: 여러 트랜잭션을 묶어 한 번에 제출하는 것(주로 Flashbots 경로).
- “오라클”: “현재 가격은 얼마” 같은 사실을 알려주는 서비스.
- “브리지”: 체인 A의 자산을 체인 B로 옮기는 길.

공통 안전 원칙(10가지 요약):
- 항상 “최소 수령 금액(minOut)”과 “최대 슬리피지”를 설정한다.
- 가스비 상한을 정하고, 손실 한도를 넘으면 즉시 중단한다.
- 외부 API(거래소/브리지)는 레이트리밋과 백오프를 적용한다.
- 키/시크릿은 환경변수/시크릿 매니저로만 관리한다.
- 시뮬레이션/리허설(드라이런)을 먼저 해보고 실전 투입한다.
- 실패 로그는 재현 가능하게 남기고, 같은 실수를 반복하지 않는다.
- 의존 서비스(노드, Redis, 브리지 API) 장애에 대비한 백업 경로를 둔다.
- 체인별 주소/토큰/수수료 정책 차이를 체크리스트로 관리한다.
- 경쟁 상황(메인넷 혼잡/이벤트)에서는 공격적 가스 사용을 피드백으로 조정한다.
- 법/규제/윤리 가이드를 정하고 준수한다.

시스템 구성(텍스트 다이어그램):
- 데이터 계층: RPC/WS, 멤풀 스트림, 오라클/브리지/거래소 API → 파서/필터 → 정규화된 이벤트/시세
- 전략 계층: 각 전략(샌드위치/청산/마이크로/크로스체인) → 점수 계산/결정 로직 → 실행 계획(Bundle/Tx/Order)
- 실행 계층: Flashbots/프라이빗/퍼블릭 제출, CEX 주문 실행, 브리지 실행
- 저장/관측: Redis(캐시/이력), 로그/메트릭, 리포트/알림

---

### 1) 샌드위치 (On-chain Sandwich)

샌드위치는 누군가 큰 스왑을 하려는 순간, 그보다 앞에서 조금 사고(가격을 올리고), 해당 사용자의 스왑이 체결된 뒤 바로 되파는 방식입니다. 핵심은 “얼마나 빠르고 안정적으로” 앞뒤를 끼워 넣느냐입니다.

- 데이터 소스
  - Mempool: 아직 블록에 포함되지 않은 “곧 일어날” 스왑 트랜잭션을 관찰합니다. 대개 큰 금액일수록 기회가 커집니다. 사용 경로: `src/mempool/*`.
  - DEX 풀 상태/이벤트: 유동성이 적은 풀일수록 가격이 크게 움직입니다. 사용 경로: `src/blockchain/contracts.rs`, `events.rs`.
  - 가스/네트워크: 혼잡한 시간에는 수수료를 더 내야 앞자리를 차지할 수 있습니다. 참고: `src/blockchain/rpc.rs`.
  - 오라클/참조가격: 무리한 가격 추정 방지(현물 대비 괴리 확인).

- 데이터 가져와서 처리하기
  - 1) “스왑 의심” 트랜잭션만 고릅니다(함수 시그니처/토큰 주소/라우터 주소 매칭).
  - 2) 예상 가격 이동(슬리피지)을 대략 계산합니다. 큰 스왑이면 가격이 크게 흔들립니다.
  - 3) 우리가 앞/뒤에 낄 때의 수익 − 가스비를 빠르게 추정합니다. 실패/경쟁 리스크 비용(확률×손실)을 보수적으로 더합니다.
  - 4) 경고 신호: 유동성 풀이 매우 얇거나, 라우팅이 복잡한 멀티홉이면 실패 가능성이 커집니다.

- 처리된 데이터 저장하기
  - 현재는 메모리 중심(짧게 들고 바로 판단). 향후 `src/storage/*`로 영속 저장(기회, 실패 원인, 성능 통계) 확대 예정.
  - 저장 항목 예시: 트랜잭션 해시, 추정 슬리피지, 예상 이익, 사용한 가스 전략, 최종 결과.

- 그 데이터로 전략 세우기
  - 규칙: “예상 이익 − (가스 + 위험 프리미엄) > 0”이면 후보. 윤리·규제 고려(정책 변화, 거래소/프로토콜 가이드라인) 포함.
  - 가스 전략: 경쟁 강도(동일 타깃을 노리는 봇 수 추정)에 따라 우선수수료를 올리되, 손실 상한을 정합니다.
  - 동시 실행 제한: 동일 블록에 과도한 시도를 제한하여 가스 낭비를 방지합니다.

- 전략결과로 실행하기
  - 번들을 구성해 Flashbots로 제출합니다. 앞 트랜잭션으로 가격 올리고, 피해자 스왑이 체결되면 뒤에서 되파는 구조.
  - 현재 라우팅/백업 번들은 기본형이며, 실패 시 다음 블록 재시도, 대체 가스전략 곡선 적용 등을 강화 예정.
  - 중요한 파라미터: amountOutMin(최소 수령), deadline, recipient, gas fee cap/priority.

- 결과 관리하기
  - 성공·실패, 실제 이익, 소요 가스, 경쟁에서 이긴 비율 등을 수집(`src/core/performance_tracker.rs`).
  - 실패 패턴(예: 예상보다 슬리피지가 컸다, 가스가 부족했다)을 분석해 필터/가스곡선/최소 이익 임계값을 조정합니다.

운영 체크리스트(샘플):
- 멤풀 스트림 정상 수신 여부
- 주요 라우터/토큰 주소 최신화
- 슬리피지/최소 수령·가스 상한 설정 확인
- 수신자 주소가 운영 지갑으로 설정되었는지 확인
- 승인(approve) 사전 체크 또는 자동 삽입 동작 확인

흔한 실패와 해결:
- 동일 기회를 노리는 경쟁자에게 밀려 실패 → 가스 전략 미세 조정, 너무 공격적이면 손실 커짐에 주의
- 멀티홉/얕은 유동성으로 슬리피지 급등 → 대상 풀 제한, 최소 유동성 임계값 도입
- 라우터 변경/토큰 주소 변경 인지 실패 → 주소 레지스트리 점검 주기화

튜닝 가이드(간단 수식):
- 기대수익 ≈ 예상 가격변화 × 거래량 − (가스 + 리스크 프리미엄)
- 가스 상한은 “블록 혼잡 지수”와 연동(혼잡↑ → 상한 완만히↑, 단 급등 구간 피하기)

예시 시나리오(수치 단순화):
- 피해자 스왑으로 가격 1% 상승 예상, 우리는 50 ETH를 먼저 매수 → 피해자 체결 후 즉시 매도
- 가스/수수료를 제외한 순이익이 0.4 ETH 이상 예상이면 실행, 아니면 패스

---

### 2) 청산 (On-chain Liquidation)

청산은 “빚이 담보보다 위험해진 계정”의 빚을 대신 갚아주고, 담보를 할인된 가격으로 받아 수익을 얻는 구조입니다. 핵심은 정확한 포지션 분석, 빠른 실행, 확실한 상환(특히 플래시론 사용 시)입니다.

- 데이터 소스
  - 대출 프로토콜 상태: Aave/Compound/MakerDAO의 담보·부채 정보.
  - 가격/오라클: Chainlink, Uniswap V3 TWAP 등을 상황에 따라 사용.
  - DEX 견적: 0x/1inch로 담보 매도 시 최적 경로 확인(백업 포함).
  - 네트워크/가스: 급할수록 가스비를 더 써서 먼저 집행해야 합니다.

- 데이터 가져와서 처리하기
  - Compound: `borrowBalanceOf/quoteCollateral`로 부채와 담보 환산가치를 산출, 여러 담보 후보 중 최대로 회수되는 조합을 고릅니다.
  - Maker: `Vat.urns/ilks`에서 `ink/art/rate/spot`를 읽어 건강도(담보가치/부채)를 계산, 저하된 포지션을 찾습니다.
  - Aave: 건강도 임계(HF<1) 근접 포지션을 탐색, 담보와 부채 토큰 매칭.
  - 동적 가스전략: “긴급도(곧 청산 가능?)”와 “경쟁도(상대 봇 많음?)”를 섞어 우선수수료를 조정합니다.

- 처리된 데이터 저장하기
  - 당장은 메모리 위주. 곧 `storage`에 포지션 스냅샷, 가격 히스토리, 경쟁자 프로파일, 청산 이벤트를 보관하도록 확장합니다.
  - 저장 항목 예시: 포지션 식별자(프로토콜/사용자), 추정 HF, 목표 청산 금액, 선택한 매도 경로, 결과/이익.

- 그 데이터로 전략 세우기
  - 원칙: 보상 − (가스 + 플래시론 수수료) > 0.
  - 청산 금액 상한: 너무 크게 잡으면 실패·슬리피지 위험 증가 → “최소 이익 달성에 필요한 수준”으로 제한.
  - 경로 선택: 플래시론(3-스텝) vs 단순 경로(승인→청산→매도). 0x는 `allowanceTarget` 승인 필요 가능.

- 전략결과로 실행하기
  - 플래시론 경로: Aave V3 `flashLoanSimple` 1개 트랜잭션에 모든 스텝을 압축. 파라미터에 `minOut=원금+9bps` 포함해 상환 안전장치.
  - 리시버 컨트랙트: `contracts/FlashLoanLiquidationReceiver.sol`이 청산→필요 시 매도→상환을 처리.
  - 비-플래시론 경로: `approve(부채토큰)`→`liquidation`→(옵션)`sell` 번들을 구성, 0x 경로면 담보 토큰도 `allowanceTarget`에 승인.
  - 구현 참고: `src/strategies/liquidation_onchain.rs`, `src/utils/abi.rs`, Foundry 스크립트(`script/DeployReceiver.s.sol`, `script/SimulateReceiver.s.sol`).

- 결과 관리하기
  - “얼마 벌었나 − 가스/수수료?”를 집계하고, 실패 원인을 기록(가격 급변, 경쟁 패배, 승인 누락 등). 데이터는 차후 재학습에 사용.
  - 포지션·가격 이력과 연동해 “타이밍 정확도”와 “가스 대비 수익”을 개선합니다.

운영 체크리스트:
- 리시버 배포 주소 설정(`config/default.toml`), 네트워크 맞춤 검증
- 0x/1inch 견적 정상, 1inch API 키 헤더 주입 확인
- Maker/Compound/Aave 주소·파라미터 최신화
- Redis 연결/키 공간 정상, 포지션/이벤트 기록 테스트
- 가스 전략 상한/하한 설정, 번들 제출 경로(Flashbots/직접) 정상

흔한 실패와 해결:
- 상환 부족으로 플래시론 롤백 → `minOut`↑, DEX 경로/슬리피지 재조정
- 승인 누락(allowanceTarget, 라우터) → 사전 승인 체크/자동 approve 삽입
- 건강도 계산 오차(오라클 지연/단위 변환 문제) → 한 단계 더 보수적으로 계산, 단위 테스트 보강

튜닝 가이드(간단 수식):
- 순이익 ≈ 청산 보상 − (가스 + 플래시론 비용 + 매도 슬리피지)
- 목표 청산 금액: “보수적 minOut을 만족하면서 수익을 남길 수 있는 최소 금액”으로 산출

예시 시나리오:
- 부채 100, 담보가치 120(임계 120)인 계정이 하락으로 HF↓ → 30만큼 청산하면 보상 1.5 예상
- DEX 경로/가스/플래시론 9bps 감안 순이익 0.7 이상이면 실행, 아니면 대기

---

### 3) 마이크로 아비트래지 (CEX/DEX/DEX-DEX 소규모 가격차)

마이크로 아비트는 “작은 가격차를 여러 번 빠르게” 노려 누적 수익을 내는 방식입니다. 한 번에 크게 벌기보다, 안전하게 여러 번 반복해 합산 수익을 만드는 것이 핵심입니다.

- 데이터 소스
  - DEX/CEX 시세·오더북·체결 피드(`src/exchange/*`). 초반에는 모의 데이터/인터페이스로 시작할 수 있습니다.
  - 네트워크 지연, 거래소 API 지연, 체결 확률(과거 통계) 같은 운용 데이터.
  - 수수료 테이블(메이커/테이커, 등급별 수수료)과 인출/입금 수수료.

- 데이터 가져와서 처리하기
  - 각 거래쌍에 대해 “현재 스프레드 − (수수료 + 예상 슬리피지 + 가스)”를 계산합니다.
  - 네트워크/거래소 지연(왕복 시간)을 고려해 실현 가능성을 평가합니다. 지연이 크면 가격이 바뀌어 기회가 사라집니다.
  - 취소·재배치 비용까지 고려해 기대값을 계산합니다.

- 처리된 데이터 저장하기
  - 실행 로그, 평균 체결 시간, 성공률을 메모리에 보관하고 점차 영속 저장(예: Redis)으로 확장합니다.
  - 심볼별·시간대별 성과 테이블을 만들어 어떤 구간이 수익이 잘 나는지 학습합니다.

- 그 데이터로 전략 세우기
  - 수익이 양수인 경우만 소량 다회전으로 접근(리스크 분산). 주문 크기는 슬리피지와 체결 가능성을 고려해 보수적으로.
  - “일일 최대 손실”, “거래당 최대 손실”, “최소 기대수익” 같은 가드레일을 설정합니다.

- 전략결과로 실행하기
  - 현재는 모의 실행기(`src/exchange/order_executor.rs`) 경로. 실제 거래소 API(키 관리/레이트리밋/리트라이)는 단계적 도입.
  - 실모드에서는 주문 전 “핑/가격 조회”로 연결 상태를 확인하고, 비정상 시 즉시 중단합니다.

- 결과 관리하기
  - 종합 성과(승률·평균 수익·표준편차)를 추적하고, 심볼별·시간대별 성과를 시각화할 수 있도록 구조화합니다.
  - 실패 유형(슬리피지 과다, 취소 실패, 레이트리밋)을 기록해 재현 가능한 재시도 정책을 만듭니다.

운영 체크리스트:
- API 키/시크릿/패스프레이즈 설정, 읽기/쓰기 권한 분리
- 레이트리밋·백오프 적용, 오더북/티커 지연 모니터링
- 최소 주문 크기/단위, 최대 포지션 한도 설정
- 타임아웃/동시 실행 수 상한 설정

흔한 실패와 해결:
- 주문 거절/레이트리밋 → 큐잉/백오프, 주문 빈도 제한
- 체결 지연으로 가격 미끄러짐 → 주문 크기 축소, 더 유동성 높은 심볼로 전환
- 수수료 과대계상/과소계상 → 수수료 테이블 정기 동기화, 실거래 기록으로 보정

튜닝 가이드(간단 수식):
- 기대수익 ≈ 스프레드 − (수수료 + 슬리피지 + 가스 + 취소비용)
- 주문 크기 = min(유동성 기반 체결가능량, 허용 슬리피지 내 최대량)

예시 시나리오:
- 거래쌍 ETH/USDT, CEX A 매수 3bp 유리, CEX B 매도 3.5bp 유리
- 수수료 합 2bp, 예상 슬리피지 0.5bp → 기대 4bp − 2.5bp = 1.5bp 양수 → 소량 반복 실행

---

### 4) 크로스체인 아비트래지

크로스체인은 체인 간 가격차/보상 차이를 이용합니다. 체인 A에서 싸게 사서 체인 B에서 비싸게 팔거나, 체인 보상/인센티브 차이를 이용합니다. 핵심은 “브리지 시간/수수료/성공률”을 정직하게 반영하는 것입니다.

- 데이터 소스
  - 브리지 견적/성능: LiFi, Stargate, Hop, Rubic, Synapse, Across, Multichain 등(`src/bridges/*`).
  - 체인별 가스비, 예상 체결 시간, 과거 성공률(내부 성능 트래커).
  - 원천/목적지 체인의 DEX 시세(필요 시 양쪽에서 환전 경로 포함).

- 데이터 가져와서 처리하기
  - `CrossChainArbitrageStrategy.scan_real_bridge_opportunities`에서 토큰·체인쌍을 조합해 견적을 모읍니다.
  - 순이익 추정: “목적지에서 실제 손에 쥘 금액 − (원천에서 준비 비용 + 두 체인의 가스비 + 브리지 수수료)”.
  - 시간 리스크: 빠른 브리지일수록 유리. 지연이 길면 가격이 바뀌어 이익이 사라질 수 있습니다.
  - 견적 만료: 대부분 유효 시간이 짧으므로 실행 직전에 재검증합니다.

- 처리된 데이터 저장하기
  - 현재는 메모리/간단 구조. 곧 브리지 성능 DB(체인×토큰×브리지별 평균 시간, 실패율, 스프레드)를 영속화하여 라우팅에 반영합니다.
  - 실패/지연 유형을 라벨링해 “어떤 브리지/체인 조합이 언제 느린지”를 학습합니다.

- 그 데이터로 전략 세우기
  - 라우팅 정책: “최저비용”, “속도-비용 균형”, “성공률 우선” 등 프로파일을 설정하고 상황에 맞게 선택합니다.
  - 백업 경로: 1차 실패 시 1회 재시도할 대체 브리지를 준비합니다(서로 독립적인 실패 가능성이 높을수록 좋음).
  - 도착 체인 DEX 실행: 필요하면 목적지에서 즉시 교환해 가격 변동 위험을 축소합니다.

- 전략결과로 실행하기
  - `bridge_manager.execute_bridge`로 라우팅된 경로를 호출합니다(초안). 실패 시 백업 경로로 즉시 전환하는 재시도 로직을 운용합니다.
  - LI.FI의 경우 `transaction_request`를 받아 체인별 서명/브로드캐스트가 필요합니다.
  - 필요하면 출발/도착 체인에서 DEX 교환을 함께 실행(예: ETH→USDC로 바꿔 이동, 도착 후 다시 ETH로).

- 결과 관리하기
  - 체인·브리지별 성과(수익·시간·성공률)를 집계하고, 히스토리를 이용해 다음번 라우팅 점수에 반영합니다.
  - 만료/지연/실패 로그를 표준 포맷으로 기록해 원인별 개선(예: 특정 시간대 Hop 지연)으로 이어갑니다.

운영 체크리스트:
- 체인별 RPC/키, 브리지 API 키(LIFI_API_KEY 등) 설정
- 두 체인 모두 가스 준비(브리지 수수료 + 도착 DEX 실행용)
- 견적 만료 시간/타임아웃/재시도 정책 외부화
- 상태 폴링 주기/최대 대기 시간 설정

흔한 실패와 해결:
- 견적 만료 직전 실행 → 실행 전 재검증, 만료 버퍼 확보(예: 30초 이상)
- 브리지 특정 시간대 지연 → 성능 히스토리 기반 브리지 우선순위 재조정
- 도착 DEX 가격 급변 → 목적지에서 즉시 교환 또는 헤지 경로 준비, 최소 수령액 엄수

튜닝 가이드(간단 수식):
- 순이익 ≈ (목적지 매도금액 − 원천 매수금액) − (브리지 수수료 + 가스 + 시간가치)
- 대체 경로 점수 = 0.7×순이익 순위 + 0.3×성공률 순위 (예시 가중치)

예시 시나리오:
- 체인 A: ETH 가격 1,995 USDC, 체인 B: 2,005 USDC → 10 USDC 차이
- 브리지/가스 총비용 4 USDC, 예상 지연 2분, 변동 리스크 고려 기대 3 USDC → 양수라면 소량 반복

---

### 공통 운영 가이드

- 가스 전략(“얼마나 공격적으로 낼까”)
  - 경쟁이 치열할수록 우선수수료를 올리되, 한계치를 정합니다. 지갑 잔고·1건당 최대 가스비 예산을 명시합니다.
  - 블록 혼잡 지표(메타/내부 산출)를 바탕으로 동적으로 조정합니다.

- 슬리피지/가격 보호
  - 모든 스왑·매도에 허용 가능한 최대 슬리피지를 설정합니다. 예상 대비 결과가 나쁘면 자동 철회합니다.
  - 오라클/참조가격과의 괴리를 체크해 이상 상황을 걸러냅니다.

- 번들/백업 라우팅
  - 1차 번들이 실패하면 즉시 2차 번들을 시도하는 구조를 둡니다(특히 샌드위치/청산).
  - 재시도는 1~2회로 제한하고, 실패 시 원인 분석 모드로 전환합니다.

- 관측/알림
  - 실패·지연·이상치(예: 수익 음수)를 즉시 알림하고, 로그로 재현 가능하게 남깁니다.
  - 주간/월간 리포트로 전략별 성과를 비교하고 자원을 재배분합니다.

운영 플레이북(요약):
- 프리플라이트: 노드 연결/키/ENV 확인 → 시뮬레이션 1회 → 제한된 실거래(소액) → 모니터링 정상 확인
- 본운용: 제한 상향 → 실패 유형 누적 분석 → 파라미터 재설정 → 주기적 재배치
- 비상정지: 손실 한도 초과/서비스 장애 시 즉시 중지, 원인 파악 후 단계적 재개

FAQ(자주 받는 질문):
- 왜 이렇게 보수적으로 하나요? → 손실을 막는 것이 수익을 늘리는 것만큼 중요합니다. “먼저 생존, 그 다음 수익”.
- 시뮬레이션이 꼭 필요할까요? → 실제 상황은 항상 변합니다. 실패를 안전하게 학습하는 유일한 방법입니다.
- 어떤 전략이 최고인가요? → 시기·시장 상태에 따라 다릅니다. 네 전략을 모두 준비하고, 상황에 맞게 스위칭하는 것이 현실적입니다.

용어 확장 사전(조금 더):
- 슬리피지: 주문으로 인해 발생하는 가격 미끄러짐. 유동성이 낮을수록 크게 발생.
- 메이커/테이커 수수료: 주문을 호가에 올리면 메이커, 즉시 체결하면 테이커.
- TWAP/VRF/기본 단위: TWAP은 일정 시간 평균가, VRF는 무작위성 검증, 토큰마다 소수점 자릿수(데시멀)가 다름.

저장소 설계(간단 청사진):
- 단기: 메모리 캐시 + 파일 로그.
- 중기: Redis에 키 체계 예시
  - `pos:{protocol}:{user}`: 포지션 스냅샷
  - `price:{symbol}`: 최근 가격 샘플 시계열
  - `liq:events:{date}`: 청산 성공/실패 이벤트
  - `mev:competitors`: 경쟁자 주소/가스 성향 요약
  - `bridge:perf:{route}`: 브리지 경로 성능 통계
- 장기: 조회 API와 대시보드, 알림 연동(슬랙/텔레그램 등).

테스트/시뮬레이션
- 로컬 체인(Anvil)과 Foundry 스크립트로 “가상의 상황”을 여러 번 재연합니다.
- 청산 플래시론은 `script/SimulateReceiver.s.sol`로 최소 동작을 검증합니다.
- 회귀 테스트로 전략 변경이 성과를 해치지 않는지 확인합니다.

다음 단계(로드맵 요약)
- 데이터: 더 많은 체인/프로토콜/브리지를 커버, 캐싱·레이트리밋·백오프 정교화.
- 실행: 가스 워 모델 고도화, 번들 백업/재시도, MEV 보호 라우팅(프라이빗 메모풀 등).
- 저장/관측: Redis 스키마 고도화, 리포트/알림 자동화, 실패 원인 분석 파이프라인.
- 안전: 슬리피지·최소수령액·타임아웃 기본값 상향, 키/권한 관리 표준화.
