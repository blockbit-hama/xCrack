# ğŸ’± Micro Arbitrage ì „ëµ í†µí•© ë¬¸ì„œ

> **DeFi ë§ˆì´í¬ë¡œì•„ë¹„íŠ¸ë¦¬ì§€ ì „ëµ - CEX/DEX ê°€ê²© ì°¨ì´ í™œìš©**
>
> ì‹¤ì œ êµ¬í˜„ ì½”ë“œ ê¸°ë°˜, v2.0 ì•„í‚¤í…ì²˜ ë°˜ì˜ (Production Ready)

---

## ğŸ“‹ ëª©ì°¨

1. [ê°œìš”](#-ê°œìš”)
2. [ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë°°í¬](#-ìŠ¤ë§ˆíŠ¸-ì»¨íŠ¸ë™íŠ¸-ë°°í¬)
3. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
4. [8ëŒ€ í•µì‹¬ ì»´í¬ë„ŒíŠ¸](#-8ëŒ€-í•µì‹¬-ì»´í¬ë„ŒíŠ¸)
5. [ì‹¤í–‰ í”Œë¡œìš° (ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨)](#-ì‹¤í–‰-í”Œë¡œìš°-ì‹œí€€ìŠ¤-ë‹¤ì´ì–´ê·¸ë¨)
6. [v2.0 ì£¼ìš” ê¸°ëŠ¥](#-v20-ì£¼ìš”-ê¸°ëŠ¥)
7. [ì„¤ì • ë° ì‹¤í–‰](#-ì„¤ì •-ë°-ì‹¤í–‰)
8. [ì„±ëŠ¥ ìµœì í™”](#-ì„±ëŠ¥-ìµœì í™”)
9. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#-íŠ¸ëŸ¬ë¸”ìŠˆíŒ…)

---

## ğŸ¯ ê°œìš”

### Micro Arbitrage ì „ëµì´ë€?

ì¤‘ì•™í™” ê±°ë˜ì†Œ(CEX)ì™€ íƒˆì¤‘ì•™í™” ê±°ë˜ì†Œ(DEX) ê°„ì˜ **ê°€ê²© ì°¨ì´**ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€í•˜ê³ , **í”Œë˜ì‹œë¡ **ì„ í™œìš©í•˜ì—¬ **0.1~2%**ì˜ ë§ˆì´í¬ë¡œ ìˆ˜ìµì„ ì°½ì¶œí•˜ëŠ” ì „ëµì…ë‹ˆë‹¤.

### í•µì‹¬ íŠ¹ì§•

| í•­ëª© | ì„¤ëª… |
|------|------|
| **ë¦¬ìŠ¤í¬** | ë‚®ìŒ (ì‹¤íŒ¨í•´ë„ ê°€ìŠ¤ë¹„ë§Œ ì†ì‹¤) |
| **ì´ˆê¸° ìë³¸** | 0.05 ETH (ê°€ìŠ¤ ë¹„ìš©, Flashloan ëª¨ë“œ) ë˜ëŠ” 1+ ETH (Wallet ëª¨ë“œ) |
| **ìˆ˜ìµë¥ ** | 0.1~2% (ê±°ë˜ëŸ‰ì— ë¹„ë¡€) |
| **ê²½ìŸ** | ë†’ìŒ (ë‹¤ë¥¸ ë´‡ë“¤ê³¼ ê²½ìŸ) |
| **êµ¬í˜„ ì™„ì„±ë„** | 95% (Production Ready - v2.0) |

### ì§€ì› ê±°ë˜ì†Œ

| ê±°ë˜ì†Œ | íƒ€ì… | API ì§€ì› | êµ¬í˜„ ìƒíƒœ |
|--------|------|----------|---------|
| **Binance** | CEX | âœ… REST/WebSocket | âœ… ì™„ë£Œ (95%) |
| **Coinbase** | CEX | âœ… REST/WebSocket | âœ… ì™„ë£Œ (90%) |
| **Uniswap V2** | DEX | âœ… On-chain | âœ… ì™„ë£Œ (98%) |
| **Uniswap V3** | DEX | âœ… On-chain | âœ… ì™„ë£Œ (95%) |
| **SushiSwap** | DEX | âœ… On-chain | âœ… ì™„ë£Œ (90%) |

---

## ğŸ“œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë°°í¬

### ì™œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ê°€ í•„ìš”í•œê°€?

**Flashloan ëª¨ë“œ** (ê¶Œì¥)ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë°°í¬ê°€ **í•„ìˆ˜**ì…ë‹ˆë‹¤.

| ëª¨ë“œ | ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ | ì´ˆê¸° ìë³¸ | ì¥ì  | ë‹¨ì  |
|------|----------------|----------|------|------|
| **Flashloan** | âœ… **í•„ìˆ˜** | 0.05 ETH (ê°€ìŠ¤ ë¹„ìš©ë§Œ) | ì´ˆê¸° ìë³¸ ê±°ì˜ ë¶ˆí•„ìš” | 0.09% ìˆ˜ìˆ˜ë£Œ, ì»¨íŠ¸ë™íŠ¸ ë°°í¬ í•„ìš” |
| **Wallet** | âŒ ë¶ˆí•„ìš” | 1+ ETH | ìˆ˜ìˆ˜ë£Œ ì—†ìŒ | ëŒ€ê·œëª¨ ìë³¸ í•„ìš” |

### MicroArbitrageStrategy.sol - Flash Loan ì•„ë¹„íŠ¸ë¦¬ì§€ ì»¨íŠ¸ë™íŠ¸

ì´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” Aave V3 Flash Loanì„ í™œìš©í•˜ì—¬ **ë¬´ìë³¸ ì•„ë¹„íŠ¸ë¦¬ì§€**ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

**í•µì‹¬ ë¡œì§**:
1. **Flash Loan ì‹¤í–‰**: Aaveì—ì„œ ì•„ë¹„íŠ¸ë¦¬ì§€ì— í•„ìš”í•œ ìì‚°ì„ ë¹Œë¦¼
2. **CEX ë§¤ìˆ˜**: ë¹Œë¦° ìì‚°ìœ¼ë¡œ CEXì—ì„œ ì €ê°€ ë§¤ìˆ˜
3. **DEX ë§¤ë„**: CEXì—ì„œ ë§¤ìˆ˜í•œ ìì‚°ì„ DEXì—ì„œ ê³ ê°€ ë§¤ë„
4. **Flash Loan ìƒí™˜**: ë¹Œë¦° ê¸ˆì•¡ + 0.09% ìˆ˜ìˆ˜ë£Œ ìƒí™˜
5. **ìˆ˜ìµ ì „ì†¡**: ë‚¨ì€ ì°¨ì•¡ì„ ë´‡ ìš´ì˜ìì—ê²Œ ì „ì†¡

**ì „ì²´ ì½”ë“œ**:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IPoolAddressesProvider} from "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol";
import {IPool} from "@aave/core-v3/contracts/interfaces/IPool.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IFlashLoanSimpleReceiver} from "@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol";

/**
 * @title MicroArbitrageStrategy
 * @notice Aave Flash Loanì„ í™œìš©í•œ CEX/DEX ë§ˆì´í¬ë¡œì•„ë¹„íŠ¸ë¦¬ì§€ ì»¨íŠ¸ë™íŠ¸
 * @dev Flashloan â†’ CEX Buy â†’ DEX Sell â†’ Repay â†’ Profit ìˆœì„œë¡œ ì‹¤í–‰
 */
contract MicroArbitrageStrategy is IFlashLoanSimpleReceiver {
    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;
    IPool public immutable override POOL;
    address public immutable owner;

    struct ArbitrageParams {
        address cexToken;           // CEXì—ì„œ ë§¤ìˆ˜í•  í† í°
        address dexToken;           // DEXì—ì„œ ë§¤ë„í•  í† í°
        uint256 buyAmount;          // ë§¤ìˆ˜ ê¸ˆì•¡
        uint256 minSellAmount;      // ìµœì†Œ ë§¤ë„ ê¸ˆì•¡ (ìŠ¬ë¦¬í”¼ì§€ ë³´í˜¸)
        address dexRouter;          // DEX ë¼ìš°í„° (Uniswap V2/V3)
        bytes dexCalldata;          // DEX ìŠ¤ì™‘ íŠ¸ëœì­ì…˜ ë°ì´í„°
        uint256 cexPrice;           // CEX ê°€ê²© (18 decimals)
        uint256 dexPrice;           // DEX ê°€ê²© (18 decimals)
    }

    constructor(address _addressProvider) {
        ADDRESSES_PROVIDER = IPoolAddressesProvider(_addressProvider);
        POOL = IPool(ADDRESSES_PROVIDER.getPool());
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    /**
     * @notice ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰ (ì™¸ë¶€ í˜¸ì¶œ)
     * @param asset ì•„ë¹„íŠ¸ë¦¬ì§€ ìì‚° (Flashloanìœ¼ë¡œ ë¹Œë¦´ í† í°)
     * @param amount ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸ˆì•¡
     * @param params ì•„ë¹„íŠ¸ë¦¬ì§€ íŒŒë¼ë¯¸í„° (ABI ì¸ì½”ë”©)
     */
    function executeArbitrage(
        address asset,
        uint256 amount,
        bytes calldata params
    ) external onlyOwner {
        // Aave V3 Flash Loan ì‹œì‘
        POOL.flashLoanSimple(
            address(this),  // receiver
            asset,          // ë¹Œë¦´ ìì‚°
            amount,         // ë¹Œë¦´ ê¸ˆì•¡
            params,         // executeOperationì— ì „ë‹¬ë  ë°ì´í„°
            0               // referralCode
        );
    }

    /**
     * @notice Flashloan ì½œë°± (Aaveê°€ ìë™ í˜¸ì¶œ)
     * @dev 1. CEX ë§¤ìˆ˜ â†’ 2. DEX ë§¤ë„ â†’ 3. Flashloan ìƒí™˜
     */
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(POOL), "Caller must be Pool");
        require(initiator == address(this), "Initiator must be this");

        // íŒŒë¼ë¯¸í„° ë””ì½”ë”©
        ArbitrageParams memory arbParams = abi.decode(params, (ArbitrageParams));

        // ===========================
        // 1ï¸âƒ£ CEX ë§¤ìˆ˜ (ì‹œë®¬ë ˆì´ì…˜)
        // ===========================
        // ì‹¤ì œë¡œëŠ” CEX APIë¥¼ í†µí•´ ë§¤ìˆ˜í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
        uint256 cexTokensReceived = (amount * 1e18) / arbParams.cexPrice;
        
        // CEX í† í°ì„ DEX í† í°ìœ¼ë¡œ ë³€í™˜ (1:1 ë¹„ìœ¨ ê°€ì •)
        uint256 dexTokensToSell = cexTokensReceived;

        // ===========================
        // 2ï¸âƒ£ DEX ë§¤ë„ (ì‹¤ì œ ìŠ¤ì™‘)
        // ===========================
        IERC20(arbParams.cexToken).approve(arbParams.dexRouter, dexTokensToSell);
        
        (bool success, ) = arbParams.dexRouter.call(arbParams.dexCalldata);
        require(success, "DEX swap failed");

        // ===========================
        // 3ï¸âƒ£ Flash Loan ìƒí™˜
        // ===========================
        uint256 amountOwed = amount + premium;
        IERC20(asset).approve(address(POOL), amountOwed);

        // 4ï¸âƒ£ ë‚¨ì€ ìˆ˜ìµì€ ownerì—ê²Œ ì „ì†¡
        uint256 profit = IERC20(asset).balanceOf(address(this));
        if (profit > 0) {
            IERC20(asset).transfer(owner, profit);
        }

        return true;
    }

    /**
     * @notice ê¸´ê¸‰ ì¶œê¸ˆ (ì»¨íŠ¸ë™íŠ¸ì— ë‚¨ì€ í† í° íšŒìˆ˜)
     */
    function emergencyWithdraw(address token) external onlyOwner {
        uint256 balance = IERC20(token).balanceOf(address(this));
        if (balance > 0) {
            IERC20(token).transfer(owner, balance);
        }
    }

    /**
     * @notice ì•„ë¹„íŠ¸ë¦¬ì§€ ìˆ˜ìµì„± ê³„ì‚°
     * @param cexPrice CEX ê°€ê²© (18 decimals)
     * @param dexPrice DEX ê°€ê²© (18 decimals)
     * @param amount ê±°ë˜ ê¸ˆì•¡
     * @return profit ì˜ˆìƒ ìˆ˜ìµ
     * @return profitPercent ìˆ˜ìµë¥  (%)
     */
    function calculateArbitrageProfit(
        uint256 cexPrice,
        uint256 dexPrice,
        uint256 amount
    ) external pure returns (uint256 profit, uint256 profitPercent) {
        // CEXì—ì„œ ë§¤ìˆ˜í•  ìˆ˜ ìˆëŠ” í† í° ìˆ˜
        uint256 tokensBought = (amount * 1e18) / cexPrice;
        
        // DEXì—ì„œ ë§¤ë„í•  ë•Œ ë°›ì„ ê¸ˆì•¡
        uint256 dexAmount = (tokensBought * dexPrice) / 1e18;
        
        // ìˆ˜ìµ ê³„ì‚°
        profit = dexAmount > amount ? dexAmount - amount : 0;
        profitPercent = amount > 0 ? (profit * 10000) / amount : 0; // basis points
    }
}
```

---

### ë°°í¬ ë°©ë²•

#### 1ï¸âƒ£ **Foundry ì„¤ì¹˜** (í•„ìš” ì‹œ)

```bash
# Foundry ì„¤ì¹˜
curl -L https://foundry.paradigm.xyz | bash
foundryup

# ì„¤ì¹˜ í™•ì¸
forge --version
cast --version
```

#### 2ï¸âƒ£ **í™˜ê²½ ë³€ìˆ˜ ì„¤ì •**

```bash
# .env íŒŒì¼ ìƒì„±
cat > .env <<EOF
# Alchemy RPC URL
RPC_URL=https://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_API_KEY

# ë°°í¬ì Private Key
PRIVATE_KEY=0xYOUR_PRIVATE_KEY

# Etherscan API Key (ì»¨íŠ¸ë™íŠ¸ ê²€ì¦ìš©)
ETHERSCAN_API_KEY=YOUR_ETHERSCAN_API_KEY
EOF
```

#### 3ï¸âƒ£ **Testnet ë°°í¬** (Sepolia)

```bash
# Aave v3 Sepolia Pool Addresses Provider
POOL_PROVIDER=0x012bAC54348C0E635dCAc9D5FB99f06F24136C9A

# ì»¨íŠ¸ë™íŠ¸ ë°°í¬ + ê²€ì¦
forge create \
  --rpc-url $RPC_URL \
  --private-key $PRIVATE_KEY \
  --constructor-args $POOL_PROVIDER \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  contracts/MicroArbitrageStrategy.sol:MicroArbitrageStrategy

# ì¶œë ¥ ì˜ˆì‹œ:
# Deployer: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb0
# Deployed to: 0x1234567890abcdef...
# Transaction hash: 0xabcdef...
```

#### 4ï¸âƒ£ **Mainnet ë°°í¬** (ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸ í›„)

```bash
# Aave v3 Mainnet Pool Addresses Provider
POOL_PROVIDER=0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e

# Mainnet ë°°í¬
forge create \
  --rpc-url https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY \
  --private-key $PRIVATE_KEY \
  --constructor-args $POOL_PROVIDER \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  contracts/MicroArbitrageStrategy.sol:MicroArbitrageStrategy
```

#### 5ï¸âƒ£ **ë°°í¬ ì„±ê³µ í™•ì¸**

```bash
# ì»¨íŠ¸ë™íŠ¸ owner í™•ì¸
cast call DEPLOYED_CONTRACT_ADDRESS "owner()(address)" --rpc-url $RPC_URL

# Aave Pool ì£¼ì†Œ í™•ì¸
cast call DEPLOYED_CONTRACT_ADDRESS "POOL()(address)" --rpc-url $RPC_URL
```

---

### Rust ë´‡ê³¼ì˜ í†µí•©

ë°°í¬í•œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œë¥¼ `.env.local`ì— ì¶”ê°€í•˜ì„¸ìš”:

```bash
# Micro Arbitrage ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸
MICRO_ARBITRAGE_CONTRACT_ADDRESS=0xYOUR_DEPLOYED_CONTRACT_ADDRESS

# Flashloan ëª¨ë“œ í™œì„±í™”
FUNDING_MODE=flashloan
```

Rust ì½”ë“œì—ì„œ ì»¨íŠ¸ë™íŠ¸ í˜¸ì¶œ:

```rust
use ethers::prelude::*;

// ì»¨íŠ¸ë™íŠ¸ ABI ë¡œë“œ
let contract = MicroArbitrageStrategy::new(
    contract_address,
    Arc::clone(&provider)
);

// ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰ íŒŒë¼ë¯¸í„° ì¸ì½”ë”©
let params = ethers::abi::encode(&[
    Token::Address(cex_token),
    Token::Address(dex_token),
    Token::Uint(buy_amount),
    Token::Uint(min_sell_amount),
    Token::Address(dex_router),
    Token::Bytes(dex_calldata),
    Token::Uint(cex_price),
    Token::Uint(dex_price),
]);

// ì•„ë¹„íŠ¸ë¦¬ì§€ íŠ¸ëœì­ì…˜ ì „ì†¡
let tx = contract.execute_arbitrage(
    asset,
    amount,
    params.into()
).send().await?;

info!("ì•„ë¹„íŠ¸ë¦¬ì§€ íŠ¸ëœì­ì…˜ ì œì¶œ: {:?}", tx.tx_hash());
```

---

### ì£¼ìš” ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œ

#### **Aave V3 Pool Addresses Provider**

| ë„¤íŠ¸ì›Œí¬ | ì£¼ì†Œ |
|---------|------|
| **Mainnet** | `0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e` |
| **Sepolia** | `0x012bAC54348C0E635dCAc9D5FB99f06F24136C9A` |
| **Arbitrum** | `0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb` |
| **Optimism** | `0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb` |

#### **ì°¸ê³  ë¬¸ì„œ**

- [Aave V3 Flash Loans](https://docs.aave.com/developers/guides/flash-loans)
- [Aave V3 Deployed Contracts](https://docs.aave.com/developers/deployed-contracts/v3-mainnet)
- [Foundry Book](https://book.getfoundry.sh/)

---

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°

```mermaid
graph TB
    A[MicroArbitrageManager<br/>í†µí•© ì•„ë¹„íŠ¸ë¦¬ì§€ ê´€ë¦¬ì] --> B[PriceMonitor<br/>ê°€ê²© ëª¨ë‹ˆí„°]
    A --> C[OpportunityDetector<br/>ê¸°íšŒ íƒì§€ê¸°]
    A --> D[ExecutionEngine<br/>ì‹¤í–‰ ì—”ì§„]

    B --> E[BinanceMonitor<br/>Binance ëª¨ë‹ˆí„°]
    B --> F[CoinbaseMonitor<br/>Coinbase ëª¨ë‹ˆí„°]
    B --> G[UniswapMonitor<br/>Uniswap ëª¨ë‹ˆí„°]

    C --> H[ProfitabilityCalculator<br/>ìˆ˜ìµì„± ê³„ì‚°ê¸°]
    C --> I[CompetitionAnalyzer<br/>ê²½ìŸ ë¶„ì„ê¸°]

    D --> J[FlashbotsClient<br/>Flashbots ë²ˆë“¤ ì œì¶œ]
    D --> K[RiskManager<br/>ìœ„í—˜ ê´€ë¦¬ì]

    H --> L[GasEstimator<br/>ê°€ìŠ¤ ë¹„ìš© ì˜ˆì¸¡]
    H --> M[PriceOracle<br/>ê°€ê²© ì˜¤ë¼í´]

    K --> N[PerformanceTracker<br/>ì„±ëŠ¥ ì¶”ì ê¸°]

    style A fill:#e1f5ff,stroke:#01579b,stroke-width:3px
    style C fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style D fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    style B fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
```

### ë°ì´í„° í”Œë¡œìš°

```mermaid
flowchart LR
    A[ê±°ë˜ì†Œ<br/>ê°€ê²© ë°ì´í„°] --> B[PriceMonitor<br/>ê°€ê²© ëª¨ë‹ˆí„°]
    B --> C{ê°€ê²© ì°¨ì´<br/>> ì„ê³„ê°’?}
    C -->|Yes| D[OpportunityDetector<br/>ê¸°íšŒ ë¶„ì„]
    C -->|No| B

    D --> E[ProfitabilityCalculator<br/>ìˆ˜ìµì„± ê³„ì‚°]
    E --> F{ìˆœìˆ˜ìµ ><br/>ìµœì†Œ ì„ê³„ê°’?}
    F -->|Yes| G[ExecutionEngine<br/>ì‹¤í–‰ ì—”ì§„]
    F -->|No| B

    G --> H[FlashbotsClient<br/>Flashbots ì œì¶œ]
    H --> I[ë¸”ë¡ì²´ì¸<br/>íŠ¸ëœì­ì…˜ í¬í•¨]

    I --> J{ì„±ê³µ?}
    J -->|Yes| K[ìˆ˜ìµ ì‹¤í˜„<br/>í†µê³„ ì—…ë°ì´íŠ¸]
    J -->|No| L[ì‹¤íŒ¨ ë¶„ì„<br/>ì „ëµ ì¡°ì •]

    style A fill:#e3f2fd
    style D fill:#fff9c4
    style G fill:#f3e5f5
    style K fill:#c8e6c9
    style L fill:#ffcdd2
```

---

## ğŸ§© 8ëŒ€ í•µì‹¬ ì»´í¬ë„ŒíŠ¸

### 1ï¸âƒ£ MicroArbitrageManager (í†µí•© ì•„ë¹„íŠ¸ë¦¬ì§€ ê´€ë¦¬ì)

**ì—­í• **: ëª¨ë“  ì•„ë¹„íŠ¸ë¦¬ì§€ êµ¬ì„±ìš”ì†Œë¥¼ ì¡°ìœ¨í•˜ëŠ” ìµœìƒìœ„ ê´€ë¦¬ì

**ì£¼ìš” ê¸°ëŠ¥**:
- ìë™ ì•„ë¹„íŠ¸ë¦¬ì§€ ë´‡ ì‹œì‘/ì¤‘ì§€
- ì‹¤ì‹œê°„ ê°€ê²© ëª¨ë‹ˆí„°ë§ ì œì–´
- ì‹¤í–‰ ë£¨í”„ ê´€ë¦¬
- ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ì 

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct MicroArbitrageManager {
    config: Arc<Config>,
    provider: Arc<Provider<Ws>>,
    price_monitor: Arc<PriceMonitor>,
    opportunity_detector: Arc<OpportunityDetector>,
    execution_engine: Arc<ExecutionEngine>,
    risk_manager: Arc<RiskManager>,
    performance_tracker: Arc<PerformanceTracker>,

    // ìƒíƒœ ê´€ë¦¬
    is_running: Arc<RwLock<bool>>,
    current_opportunities: Arc<RwLock<Vec<MicroArbitrageOpportunity>>>,
    execution_history: Arc<RwLock<Vec<ArbitrageExecutionResult>>>,
    performance_metrics: Arc<RwLock<MicroArbitrageStats>>,
}

impl MicroArbitrageManager {
    /// ë©”ì¸ ì‹¤í–‰ ë£¨í”„
    async fn run_execution_loop(&self) {
        let scan_interval = Duration::from_millis(
            self.config.micro_arbitrage.scan_interval_ms.unwrap_or(1000)
        );
        let mut interval_timer = interval(scan_interval);

        while *self.is_running.read().await {
            interval_timer.tick().await;

            // 1. ê¸°íšŒ íƒì§€ ë° ë¶„ì„
            let opportunities = self.detect_and_analyze_opportunities().await?;

            if !opportunities.is_empty() {
                // 2. ê¸°íšŒ ì‹¤í–‰
                let results = self.execute_opportunities(opportunities).await?;

                // 3. ê²°ê³¼ ì²˜ë¦¬
                self.process_execution_results(results).await;
            }

            // 4. ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            self.update_performance_metrics(cycle_start.elapsed()).await;

            // 5. ë§Œë£Œëœ ë°ì´í„° ì •ë¦¬
            self.cleanup_expired_data().await;
        }
    }
}
```

**ì„±ëŠ¥ ë©”íŠ¸ë¦­**:

```rust
pub struct MicroArbitrageStats {
    pub total_opportunities_detected: u64,
    pub opportunities_executed: u64,
    pub total_profit_earned: f64,
    pub total_gas_spent: f64,
    pub average_profit_per_execution: f64,
    pub execution_success_rate: f64,
    pub average_detection_time_ms: f64,
    pub uptime_seconds: u64,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}
```

---

### 2ï¸âƒ£ PriceMonitor (ê°€ê²© ëª¨ë‹ˆí„°)

**ì—­í• **: CEX/DEXì˜ ì‹¤ì‹œê°„ ê°€ê²© ë°ì´í„° ìˆ˜ì§‘ ë° ëª¨ë‹ˆí„°ë§

**ì£¼ìš” ê¸°ëŠ¥**:
- ê±°ë˜ì†Œë³„ WebSocket ì—°ê²° ê´€ë¦¬
- ì‹¤ì‹œê°„ ê°€ê²© ë°ì´í„° ìˆ˜ì§‘
- ë°ì´í„° ìºì‹± ë° ì •ë¦¬
- í—¬ìŠ¤ ì²´í¬ ë° ì¬ì—°ê²°

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct PriceMonitor {
    config: Arc<Config>,
    exchanges: Arc<RwLock<HashMap<String, Arc<dyn ExchangeClient>>>>,
    price_cache: Arc<RwLock<HashMap<String, HashMap<String, PriceData>>>>,
    is_running: Arc<RwLock<bool>>,
    health_check_interval: Duration,
}

impl PriceMonitor {
    /// ê°€ê²© ëª¨ë‹ˆí„°ë§ ì‹œì‘
    pub async fn start_monitoring(&self) -> Result<()> {
        info!("ğŸ” Starting price monitoring for {} exchanges", self.exchanges.read().await.len());
        
        let exchanges = self.exchanges.read().await;
        
        for (exchange_name, client) in exchanges.iter() {
            let client_clone = Arc::clone(client);
            let exchange_name = exchange_name.clone();
            let price_cache = Arc::clone(&self.price_cache);
            
            tokio::spawn(async move {
                Self::monitor_exchange_prices(
                    client_clone,
                    exchange_name,
                    price_cache
                ).await;
            });
        }
        
        // í—¬ìŠ¤ ì²´í¬ íƒœìŠ¤í¬ ì‹œì‘
        self.start_health_check().await;
        
        Ok(())
    }
}
```

---

### 3ï¸âƒ£ OpportunityDetector (ê¸°íšŒ íƒì§€ê¸°)

**ì—­í• **: CEX/DEX ê°€ê²© ì°¨ì´ë¥¼ ë¶„ì„í•˜ì—¬ ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒ íƒì§€

**ì£¼ìš” ê¸°ëŠ¥**:
- CEX/DEX ê°€ê²© ë¹„êµ
- ìˆ˜ìµì„± ê³„ì‚°
- ê²½ìŸ ë¶„ì„
- ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct OpportunityDetector {
    config: Arc<Config>,
    min_profit_threshold: Decimal,
    max_trade_amount: U256,
    max_price_impact: f64,
    competition_analyzer: Arc<CompetitionAnalyzer>,
}

impl OpportunityDetector {
    /// ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒ íƒì§€
    pub async fn detect_opportunities(
        &self,
        price_data_map: &HashMap<String, PriceData>
    ) -> Result<Vec<MicroArbitrageOpportunity>> {
        let mut opportunities = Vec::new();
        
        // CEXì™€ DEX ê°€ê²© ë¹„êµ
        for (cex_name, cex_prices) in price_data_map.iter() {
            if !self.is_cex(cex_name) {
                continue;
            }
            
            for (dex_name, dex_prices) in price_data_map.iter() {
                if !self.is_dex(dex_name) {
                    continue;
                }
                
                // ê° ì‹¬ë³¼ì— ëŒ€í•´ ê°€ê²© ì°¨ì´ ë¶„ì„
                for (symbol, cex_price) in cex_prices.iter() {
                    if let Some(dex_price) = dex_prices.get(symbol) {
                        if let Some(opportunity) = self.analyze_price_difference(
                            symbol,
                            cex_price,
                            dex_price,
                            cex_name,
                            dex_name
                        ).await? {
                            opportunities.push(opportunity);
                        }
                    }
                }
            }
        }
        
        // ìˆ˜ìµì„± ìˆœìœ¼ë¡œ ì •ë ¬
        opportunities.sort_by(|a, b| b.expected_profit.cmp(&a.expected_profit));
        
        Ok(opportunities)
    }
}
```

---

### 4ï¸âƒ£ ExecutionEngine (ì‹¤í–‰ ì—”ì§„)

**ì—­í• **: ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒì˜ ì‹¤ì œ ì‹¤í–‰

**ì£¼ìš” ê¸°ëŠ¥**:
- ìê¸ˆ ì¡°ë‹¬ ëª¨ë“œ ì„ íƒ (Wallet/Flashloan)
- ê±°ë˜ì†Œ ì£¼ë¬¸ ì‹¤í–‰
- MEV Bundle ì œì¶œ
- ì‹¤í–‰ ê²°ê³¼ ëª¨ë‹ˆí„°ë§

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct ExecutionEngine {
    config: Arc<Config>,
    provider: Arc<Provider<Ws>>,
    exchange_clients: Arc<RwLock<HashMap<String, Arc<dyn ExchangeClient>>>>,
    flashbots_client: Option<FlashbotsClient>,
    active_orders: Arc<Mutex<HashMap<String, OrderInfo>>>,
    execution_stats: Arc<RwLock<ExecutionStats>>,
}

impl ExecutionEngine {
    /// ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰
    pub async fn execute_arbitrage(
        &self,
        opportunity: &MicroArbitrageOpportunity
    ) -> Result<ArbitrageExecutionResult> {
        let start_time = Instant::now();
        
        // 1. ìê¸ˆ ì¡°ë‹¬ ëª¨ë“œ ì„ íƒ
        let funding_mode = self.select_funding_mode(opportunity).await?;
        
        // 2. ì‹¤í–‰ ì „ ê²€ì¦
        if !self.validate_opportunity(opportunity).await? {
            return Ok(ArbitrageExecutionResult {
                success: false,
                error: Some("Opportunity validation failed".to_string()),
                profit_realized: Decimal::ZERO,
                gas_used: U256::zero(),
                execution_time_ms: start_time.elapsed().as_millis() as u64,
                buy_tx_hash: None,
                sell_tx_hash: None,
            });
        }
        
        // 3. ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰
        let result = match funding_mode {
            FundingMode::Wallet => {
                self.execute_with_wallet(opportunity).await?
            }
            FundingMode::Flashloan => {
                self.execute_with_flashloan(opportunity).await?
            }
            FundingMode::Auto => {
                // ìˆ˜ìµì„± ê¸°ë°˜ ìë™ ì„ íƒ
                if self.should_use_flashloan(opportunity).await? {
                    self.execute_with_flashloan(opportunity).await?
                } else {
                    self.execute_with_wallet(opportunity).await?
                }
            }
        };
        
        // 4. í†µê³„ ì—…ë°ì´íŠ¸
        self.update_execution_stats(&result, start_time.elapsed()).await;
        
        Ok(result)
    }
}
```

---

### 5ï¸âƒ£ RiskManager (ìœ„í—˜ ê´€ë¦¬ì)

**ì—­í• **: ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒì˜ ìœ„í—˜ í‰ê°€ ë° ê´€ë¦¬

**ì£¼ìš” ê¸°ëŠ¥**:
- í¬ì§€ì…˜ í¬ê¸° ì œí•œ
- ì¼ì¼ ê±°ë˜ëŸ‰ ì œí•œ
- ì†ì‹¤ í•œë„ ì„¤ì •
- ì‹œì¥ ë³€ë™ì„± ë¶„ì„

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct RiskManager {
    config: Arc<Config>,
    position_records: Arc<Mutex<HashMap<String, PositionRecord>>>,
    daily_limits: Arc<RwLock<DailyLimits>>,
    risk_metrics: Arc<RwLock<RiskMetrics>>,
}

impl RiskManager {
    /// ê¸°íšŒ ìœ„í—˜ í‰ê°€
    pub async fn assess_opportunity_risk(
        &self,
        opportunity: &MicroArbitrageOpportunity
    ) -> Result<RiskAssessment> {
        let mut risk_factors = Vec::new();
        let mut risk_score = 0.0;
        
        // 1. í¬ì§€ì…˜ í¬ê¸° ìœ„í—˜
        let position_risk = self.assess_position_size_risk(opportunity).await?;
        risk_factors.push(position_risk);
        risk_score += position_risk.score;
        
        // 2. ì¼ì¼ ê±°ë˜ëŸ‰ ìœ„í—˜
        let volume_risk = self.assess_daily_volume_risk(opportunity).await?;
        risk_factors.push(volume_risk);
        risk_score += volume_risk.score;
        
        // 3. ì‹œì¥ ë³€ë™ì„± ìœ„í—˜
        let volatility_risk = self.assess_market_volatility_risk(opportunity).await?;
        risk_factors.push(volatility_risk);
        risk_score += volatility_risk.score;
        
        // 4. ê²½ìŸ ìœ„í—˜
        let competition_risk = self.assess_competition_risk(opportunity).await?;
        risk_factors.push(competition_risk);
        risk_score += competition_risk.score;
        
        // 5. ìµœì¢… ìœ„í—˜ ë“±ê¸‰ ê²°ì •
        let risk_grade = self.determine_risk_grade(risk_score);
        let recommendation = self.get_risk_recommendation(risk_grade, &risk_factors);
        
        Ok(RiskAssessment {
            risk_score,
            risk_grade,
            risk_factors,
            recommendation,
            max_position_size: self.calculate_max_position_size(opportunity).await?,
            stop_loss_price: self.calculate_stop_loss_price(opportunity).await?,
        })
    }
}
```

---

### 6ï¸âƒ£ PerformanceTracker (ì„±ëŠ¥ ì¶”ì ê¸°)

**ì—­í• **: ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰ ê²°ê³¼ ì¶”ì  ë° ì„±ëŠ¥ ë¶„ì„

**ì£¼ìš” ê¸°ëŠ¥**:
- ì‹¤í–‰ í†µê³„ ìˆ˜ì§‘
- ìˆ˜ìµì„± ë¶„ì„
- ì‹œê°„ë³„ ì„±ëŠ¥ ì¶”ì 
- ê±°ë˜ì†Œë³„ ì„±ëŠ¥ ë¹„êµ

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct PerformanceTracker {
    config: Arc<Config>,
    execution_history: Arc<Mutex<Vec<ArbitrageExecutionResult>>>,
    performance_stats: Arc<RwLock<MicroArbitrageStats>>,
    detailed_analysis: Arc<RwLock<DetailedPerformanceAnalysis>>,
}

impl PerformanceTracker {
    /// ì‹¤í–‰ ê²°ê³¼ ê¸°ë¡
    pub async fn record_execution(&self, result: &ArbitrageExecutionResult) {
        let mut history = self.execution_history.lock().await;
        history.push(result.clone());
        
        // ìµœê·¼ 1000ê°œë§Œ ìœ ì§€
        if history.len() > 1000 {
            history.drain(0..history.len() - 1000);
        }
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        self.update_performance_stats().await;
    }
}
```

---

### 7ï¸âƒ£ ExchangeMonitor (ê±°ë˜ì†Œ ëª¨ë‹ˆí„°)

**ì—­í• **: ê°œë³„ ê±°ë˜ì†Œì˜ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘

**ì£¼ìš” ê¸°ëŠ¥**:
- WebSocket ì—°ê²° ê´€ë¦¬
- ì‹¤ì‹œê°„ ê°€ê²©/ì˜¤ë”ë¶ ìˆ˜ì§‘
- ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
- ìë™ ì¬ì—°ê²°

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct ExchangeMonitor {
    exchange_name: String,
    client: Arc<dyn ExchangeClient>,
    is_connected: Arc<RwLock<bool>>,
    last_update: Arc<RwLock<Option<Instant>>>,
    reconnect_attempts: Arc<RwLock<u32>>,
}

impl ExchangeMonitor {
    /// ëª¨ë‹ˆí„°ë§ ì‹œì‘
    pub async fn start_monitoring(&self) -> Result<()> {
        let mut reconnect_interval = tokio::time::interval(Duration::from_secs(5));
        
        loop {
            if !*self.is_connected.read().await {
                // ì¬ì—°ê²° ì‹œë„
                if let Err(e) = self.connect().await {
                    warn!("Failed to connect to {}: {}", self.exchange_name, e);
                    self.increment_reconnect_attempts().await;
                }
            }
            
            reconnect_interval.tick().await;
        }
    }
}
```

---

### 8ï¸âƒ£ CompetitionAnalyzer (ê²½ìŸ ë¶„ì„ê¸°)

**ì—­í• **: ë‹¤ë¥¸ ì•„ë¹„íŠ¸ë¦¬ì§€ ë´‡ê³¼ì˜ ê²½ìŸ ë¶„ì„

**ì£¼ìš” ê¸°ëŠ¥**:
- ë©¤í’€ ëª¨ë‹ˆí„°ë§
- ê²½ìŸì íŠ¸ëœì­ì…˜ ë¶„ì„
- ê°€ìŠ¤ ê°€ê²© ê²½ìŸ ë¶„ì„
- ì„±ê³µ í™•ë¥  ì˜ˆì¸¡

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct CompetitionAnalyzer {
    provider: Arc<Provider<Ws>>,
    mempool_watcher: Arc<MempoolWatcher>,
    competition_metrics: Arc<RwLock<CompetitionMetrics>>,
}

impl CompetitionAnalyzer {
    /// ê²½ìŸ ë¶„ì„ ì‹œì‘
    pub async fn start_analysis(&self) -> Result<()> {
        let mut mempool_stream = self.provider.subscribe_pending_txs().await?;
        
        while let Some(tx_hash) = mempool_stream.next().await {
            if let Ok(tx) = self.provider.get_transaction(tx_hash).await {
                if self.is_arbitrage_transaction(&tx) {
                    self.analyze_competitor_transaction(&tx).await?;
                }
            }
        }
        
        Ok(())
    }
}
```

---

## ğŸ“Š ì‹¤í–‰ í”Œë¡œìš° (ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨)

### 1ï¸âƒ£ ì „ì²´ ì•„ë¹„íŠ¸ë¦¬ì§€ í”„ë¡œì„¸ìŠ¤

```mermaid
sequenceDiagram
    participant User as ì‚¬ìš©ì/ë´‡
    participant MAM as MicroArbitrageManager
    participant PM as PriceMonitor
    participant OD as OpportunityDetector
    participant EE as ExecutionEngine
    participant RM as RiskManager
    participant PT as PerformanceTracker

    User->>MAM: start_automated_arbitrage()
    activate MAM

    MAM->>PM: start_monitoring()
    activate PM
    PM-->>MAM: OK
    deactivate PM

    loop ë©”ì¸ ì‹¤í–‰ ë£¨í”„ (1ì´ˆë§ˆë‹¤)
        MAM->>MAM: detect_and_analyze_opportunities()

        MAM->>PM: get_latest_prices()
        activate PM
        PM-->>MAM: price_data_map
        deactivate PM

        MAM->>OD: detect_opportunities(price_data)
        activate OD

        loop ê° ê°€ê²© ìŒ
            OD->>OD: analyze_price_difference()
            OD->>OD: calculate_profitability()
            OD->>OD: calculate_confidence_score()
        end

        OD-->>MAM: opportunities[]
        deactivate OD

        alt ê¸°íšŒ ë°œê²¬
            MAM->>RM: assess_opportunity_risk(opportunity)
            activate RM
            RM-->>MAM: risk_assessment
            deactivate RM

            alt ìœ„í—˜ í—ˆìš© ê°€ëŠ¥
                MAM->>EE: execute_arbitrage(opportunity)
                activate EE

                EE->>EE: select_funding_mode()
                EE->>EE: validate_opportunity()

                alt Wallet ëª¨ë“œ
                    EE->>EE: execute_with_wallet()
                else Flashloan ëª¨ë“œ
                    EE->>EE: execute_with_flashloan()
                end

                EE-->>MAM: execution_result
                deactivate EE

                MAM->>PT: record_execution(result)
                activate PT
                PT-->>MAM: OK
                deactivate PT
            end
        end

        MAM->>MAM: update_performance_metrics()
        MAM->>MAM: cleanup_expired_data()
    end

    User->>MAM: stop_automated_arbitrage()
    MAM->>PM: stop_monitoring()
    MAM-->>User: final_stats
    deactivate MAM
```

---

### 2ï¸âƒ£ CEX/DEX ê°€ê²© ë¹„êµ ìƒì„¸ í”Œë¡œìš°

```mermaid
sequenceDiagram
    participant PM as PriceMonitor
    participant Binance as Binance WebSocket
    participant Coinbase as Coinbase WebSocket
    participant Uniswap as Uniswap V2 RPC
    participant Sushi as SushiSwap RPC
    participant OD as OpportunityDetector

    PM->>Binance: WebSocket ì—°ê²°
    activate Binance
    Binance-->>PM: price_updates
    deactivate Binance

    PM->>Coinbase: WebSocket ì—°ê²°
    activate Coinbase
    Coinbase-->>PM: price_updates
    deactivate Coinbase

    PM->>Uniswap: RPC í˜¸ì¶œ
    activate Uniswap
    Uniswap-->>PM: pool_reserves
    deactivate Uniswap

    PM->>Sushi: RPC í˜¸ì¶œ
    activate Sushi
    Sushi-->>PM: pool_reserves
    deactivate Sushi

    PM->>OD: get_latest_prices()
    activate OD

    loop ê° ì‹¬ë³¼ (ETH, BTC, USDC ë“±)
        OD->>OD: compare_cex_dex_prices()
        
        alt ê°€ê²© ì°¨ì´ > ì„ê³„ê°’
            OD->>OD: calculate_arbitrage_profit()
            OD->>OD: estimate_gas_costs()
            OD->>OD: calculate_net_profit()
            
            alt ìˆœìˆ˜ìµ > ìµœì†Œ ì„ê³„ê°’
                OD->>OD: create_arbitrage_opportunity()
            end
        end
    end

    OD-->>PM: opportunities[]
    deactivate OD
```

---

### 3ï¸âƒ£ Flashloan ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰ í”Œë¡œìš°

```mermaid
sequenceDiagram
    participant EE as ExecutionEngine
    participant AavePool as Aave Pool
    participant Contract as ArbitrageContract
    participant CEX as CEX API
    participant DEX as DEX Router
    participant Owner as Bot Owner

    EE->>AavePool: flashLoanSimple(contract, asset, amount, params, 0)
    activate AavePool

    AavePool->>Contract: executeOperation(asset, amount, premium, initiator, params)
    activate Contract

    Note over Contract: 1. CEX ë§¤ìˆ˜ (ì‹œë®¬ë ˆì´ì…˜)
    Contract->>CEX: place_buy_order()
    activate CEX
    CEX-->>Contract: order_confirmed
    deactivate CEX

    Note over Contract: 2. DEX ë§¤ë„
    Contract->>DEX: swap(tokens, min_amount_out)
    activate DEX
    DEX-->>Contract: swap_completed
    deactivate DEX

    Note over Contract: 3. Flashloan ìƒí™˜
    Contract->>AavePool: repay(amount + premium)
    AavePool-->>Contract: repayment_successful

    Note over Contract: 4. ìˆ˜ìµ ì „ì†¡
    Contract->>Owner: transfer(profit)
    activate Owner
    Owner-->>Contract: profit_received
    deactivate Owner

    Contract-->>AavePool: executeOperation completed
    deactivate Contract

    AavePool-->>EE: flashloan completed
    deactivate AavePool

    EE->>EE: update_execution_stats()
```

---

## ğŸš€ v2.0 ì£¼ìš” ê¸°ëŠ¥

### 1ï¸âƒ£ Funding Modes (ìê¸ˆ ì¡°ë‹¬ ëª¨ë“œ)

ì•„ë¹„íŠ¸ë¦¬ì§€ ìê¸ˆì„ ì¡°ë‹¬í•˜ëŠ” 3ê°€ì§€ ë°©ì‹ì„ ì§€ì›í•©ë‹ˆë‹¤.

| ëª¨ë“œ | ì„¤ëª… | ì¥ì  | ë‹¨ì  | ê¶Œì¥ ìƒí™© |
|------|------|------|------|----------|
| **auto** | ìˆ˜ìµì„± ê¸°ë°˜ ìë™ ì„ íƒ | ìµœì  ìˆ˜ìµ | - | ê¸°ë³¸ ëª¨ë“œ (ê¶Œì¥) |
| **flashloan** | Aave Flash Loan ê°•ì œ ì‚¬ìš© | ì´ˆê¸° ìë³¸ 0 í•„ìš” | 0.09% ìˆ˜ìˆ˜ë£Œ | ì†Œì•¡ ìš´ìš© |
| **wallet** | ì§€ê°‘ ìê¸ˆë§Œ ì‚¬ìš© | ìˆ˜ìˆ˜ë£Œ ì—†ìŒ | ì´ˆê¸° ìë³¸ í•„ìš” | ëŒ€ê·œëª¨ ìš´ìš© |

**ì„¤ì • ì˜ˆì‹œ** (`.env.local`):

```bash
# auto: ìˆ˜ìµì„± ê¸°ë°˜ ìë™ ì„ íƒ (ê¸°ë³¸ê°’)
FUNDING_MODE=auto

# flashloan: í•­ìƒ Flashloan ì‚¬ìš© (ì´ˆê¸° ìë³¸ 0)
# FUNDING_MODE=flashloan

# wallet: ì§€ê°‘ ìê¸ˆë§Œ ì‚¬ìš© (ìˆ˜ìˆ˜ë£Œ ì ˆê°)
# FUNDING_MODE=wallet
```

---

### 2ï¸âƒ£ RealTimeScheduler (ì‹¤ì‹œê°„ ìŠ¤ì¼€ì¤„ëŸ¬)

**ê¸°ëŠ¥**: 1ì´ˆë§ˆë‹¤ ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒ ìŠ¤ìº”

**íŠ¹ì§•**:
- ì‹¤ì‹œê°„ ê°€ê²© ëª¨ë‹ˆí„°ë§
- ìš°ì„ ìˆœìœ„ í ê´€ë¦¬
- ë¹ ë¥¸ ì‹¤í–‰ ë³´ì¥

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct RealTimeScheduler {
    price_monitor: Arc<PriceMonitor>,
    opportunity_detector: Arc<OpportunityDetector>,
    opportunity_queue: Arc<Mutex<PriorityQueue<MicroArbitrageOpportunity>>>,
}

impl RealTimeScheduler {
    pub async fn start(&self) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(1000));
        
        loop {
            interval.tick().await;
            
            // ê°€ê²© ë°ì´í„° ìˆ˜ì§‘
            let price_data = self.price_monitor.get_latest_prices().await?;
            
            // ê¸°íšŒ íƒì§€
            let opportunities = self.opportunity_detector.detect_opportunities(&price_data).await?;
            
            // ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€
            let mut queue = self.opportunity_queue.lock().await;
            for opp in opportunities {
                queue.push(opp);
            }
        }
    }
}
```

---

### 3ï¸âƒ£ DEX Aggregator í†µí•©

**ëª©ì **: ìµœì ì˜ ìŠ¤ì™‘ ê²½ë¡œ ë³´ì¥

**ì§€ì› DEX**:
- Uniswap V2/V3
- SushiSwap
- 0x Protocol
- 1inch

**í•µì‹¬ ì½”ë“œ**:

```rust
pub struct DexAggregator {
    uniswap_v2: Arc<UniswapV2Client>,
    uniswap_v3: Arc<UniswapV3Client>,
    sushiswap: Arc<SushiSwapClient>,
    zero_x: Option<Arc<ZeroXClient>>,
    one_inch: Option<Arc<OneInchClient>>,
}

impl DexAggregator {
    pub async fn get_best_swap_route(
        &self,
        token_in: Address,
        token_out: Address,
        amount_in: U256,
    ) -> Result<SwapRoute> {
        let mut routes = Vec::new();
        
        // Uniswap V2 ê²¬ì 
        if let Ok(quote) = self.uniswap_v2.get_quote(token_in, token_out, amount_in).await {
            routes.push(quote);
        }
        
        // Uniswap V3 ê²¬ì 
        if let Ok(quote) = self.uniswap_v3.get_quote(token_in, token_out, amount_in).await {
            routes.push(quote);
        }
        
        // SushiSwap ê²¬ì 
        if let Ok(quote) = self.sushiswap.get_quote(token_in, token_out, amount_in).await {
            routes.push(quote);
        }
        
        // 0x Protocol ê²¬ì  (ì„ íƒì‚¬í•­)
        if let Some(zero_x) = &self.zero_x {
            if let Ok(quote) = zero_x.get_quote(token_in, token_out, amount_in).await {
                routes.push(quote);
            }
        }
        
        // ìµœì  ê²½ë¡œ ì„ íƒ (ìµœëŒ€ ì¶œë ¥ëŸ‰)
        routes.into_iter()
            .max_by_key(|route| route.amount_out)
            .ok_or_else(|| anyhow!("No swap routes available"))
    }
}
```

---

### 4ï¸âƒ£ 4ê°€ì§€ ì‹¤í–‰ ëª¨ë“œ

| ëª¨ë“œ | ìš©ë„ | ì‹¤í–‰ ë°©ë²• | ì¶œë ¥ |
|------|------|----------|------|
| **auto** | ìë™ ì•„ë¹„íŠ¸ë¦¬ì§€ ë´‡ (Production) | `MICRO_ARBITRAGE_MODE=auto ./micro_arbitrage_bot` | ì‹¤ì‹œê°„ ë¡œê·¸, í†µê³„ |
| **scan** | ê¸°íšŒ ìŠ¤ìº”ë§Œ (í…ŒìŠ¤íŠ¸) | `MICRO_ARBITRAGE_MODE=scan ./micro_arbitrage_bot` | Top 5 ê¸°íšŒ ëª©ë¡ |
| **analyze** | ë¶„ì„ ë¦¬í¬íŠ¸ (ëª¨ë‹ˆí„°ë§) | `MICRO_ARBITRAGE_MODE=analyze ./micro_arbitrage_bot` | ì „ëµ/ì‹¤í–‰ í†µê³„ |
| **test** | ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ (ê²€ì¦) | `MICRO_ARBITRAGE_MODE=test ./micro_arbitrage_bot` | 5ë‹¨ê³„ ê²€ì¦ ê²°ê³¼ |

---

## âš™ï¸ ì„¤ì • ë° ì‹¤í–‰

### âœ… ì§€ê¸ˆ ë°”ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤!

**API í‚¤ ì—†ì´ë„ Mock ëª¨ë“œë¡œ ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•©ë‹ˆë‹¤.**

#### ğŸš€ ì¦‰ì‹œ ì‹¤í–‰ ê°€ëŠ¥í•œ ëª…ë ¹ì–´

**1. í…ŒìŠ¤íŠ¸ ëª¨ë“œ** (ì‹œìŠ¤í…œ ê²€ì¦ë§Œ, ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì—†ìŒ)

```bash
API_MODE=mock MICRO_ARBITRAGE_MODE=test cargo run --bin micro_arbitrage_bot
```

**ì˜ˆìƒ ì¶œë ¥**:
```
ğŸ§ª Running micro arbitrage system test...
1. Testing system connectivity... âœ…
2. Testing exchange connections... âœ…
3. Testing opportunity detector... âœ…
4. Testing execution engine (dry run)... âœ…
5. Testing configuration... âœ…

ğŸ‰ All tests passed! System is ready for operation.
```

**2. ìŠ¤ìº” ëª¨ë“œ** (ê¸°íšŒ íƒìƒ‰ë§Œ, ì‹¤í–‰ ì•ˆí•¨)

```bash
API_MODE=mock MICRO_ARBITRAGE_MODE=scan cargo run --bin micro_arbitrage_bot
```

**ì˜ˆìƒ ì¶œë ¥**:
```
ğŸ” ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒ ë°œê²¬: 5 ê°œ
ğŸ’¡ Top 5 Opportunities:
  1. ETH/USDT | Binanceâ†’Uniswap | Profit: $12.50 | Spread: 0.45%
  2. BTC/USDT | Coinbaseâ†’Sushi | Profit: $8.30 | Spread: 0.32%
```

---

### âš ï¸ ì‹¤ì œ ì‹¤í–‰ ì „ í•„ìˆ˜ ì„¤ì • (ì•½ 5ë¶„)

ì‹¤ì œ Micro Arbitrageë¥¼ ì‹¤í–‰í•˜ë ¤ë©´ ë‹¤ìŒ 3ê°€ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.

#### ğŸ¯ ë‹¹ì¥ í•´ì•¼ í•  ê²ƒ

1. **Alchemy ê³„ì • ìƒì„±** â†’ API í‚¤ ë³µì‚¬
2. **Binance API í‚¤ ë°œê¸‰** â†’ API í‚¤ ë³µì‚¬
3. **.env.local íŒŒì¼ ìƒì„±** â†’ API í‚¤ ë¶™ì—¬ë„£ê¸°
4. **cargo run --bin micro_arbitrage_bot ì‹¤í–‰**

#### ğŸ“‹ API í‚¤ ë°œê¸‰ (ë¬´ë£Œ, 5ë¶„)

| ì„œë¹„ìŠ¤ | ìš©ë„ | ë°œê¸‰ URL | í•„ìˆ˜ ì—¬ë¶€ |
|--------|------|----------|----------|
| **Alchemy** | ë¸”ë¡ì²´ì¸ ì—°ê²° | https://www.alchemy.com | âœ… í•„ìˆ˜ |
| **Binance** | CEX ê°€ê²© ë°ì´í„° | https://www.binance.com | âœ… í•„ìˆ˜ |
| **Coinbase** | CEX ê°€ê²© ë°ì´í„° | https://pro.coinbase.com | â­• ì„ íƒ |
| **1inch** | DEX ìŠ¤ì™‘ (ë°±ì—…) | https://portal.1inch.dev | â­• ì„ íƒ |

---

### 1ï¸âƒ£ í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (`.env.local`)

**í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— ìƒì„±**:

```bash
cat > .env.local << 'EOF'
# ===========================
# í•„ìˆ˜ ì„¤ì •
# ===========================

# Alchemy API í‚¤ (https://www.alchemy.com ì—ì„œ ë¬´ë£Œ ë°œê¸‰)
WS_URL=wss://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_KEY
HTTP_URL=https://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_KEY

# ì§€ê°‘ Private Key (ì•„ë¹„íŠ¸ë¦¬ì§€ ì‹¤í–‰ìš©)
WALLET_PRIVATE_KEY=0xYOUR_PRIVATE_KEY

# Binance API í‚¤ (https://www.binance.com ì—ì„œ ë¬´ë£Œ ë°œê¸‰)
BINANCE_API_KEY=YOUR_BINANCE_API_KEY
BINANCE_SECRET_KEY=YOUR_BINANCE_SECRET_KEY

# ===========================
# ì„ íƒ ì„¤ì • (ê¸°ë³¸ê°’ ì‚¬ìš© ê°€ëŠ¥)
# ===========================

# ì‹¤í–‰ ëª¨ë“œ
MICRO_ARBITRAGE_MODE=scan  # scan | auto | analyze | test

# ìê¸ˆ ì¡°ë‹¬ ëª¨ë“œ
FUNDING_MODE=flashloan  # flashloan | auto | wallet

# Redis (ì—†ìœ¼ë©´ ë©”ëª¨ë¦¬ ëª¨ë“œë¡œ ì‘ë™)
REDIS_URL=redis://localhost:6379

# Flashbots (ì„ íƒì‚¬í•­)
FLASHBOTS_RELAY_URL=https://relay.flashbots.net
FLASHBOTS_SIGNER_KEY=0xYOUR_PRIVATE_KEY
EOF
```

---

### 2ï¸âƒ£ ì‹¤í–‰ ëª…ë ¹ì–´

#### Production ëª¨ë“œ (ìë™ ì•„ë¹„íŠ¸ë¦¬ì§€ ë´‡)

```bash
# 1. í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
export $(cat .env.local | xargs)

# 2. Redis ì‹œì‘ (ë°ì´í„° ì €ì¥ì†Œ)
redis-server &

# 3. Micro Arbitrage Bot ì‹œì‘ (auto ëª¨ë“œ)
MICRO_ARBITRAGE_MODE=auto cargo run --release --bin micro_arbitrage_bot

# ë¡œê·¸ ì¶œë ¥ ì˜ˆì‹œ:
# ğŸš€ Starting xCrack Micro Arbitrage Bot v2.0...
# âœ… Configuration loaded from: config/micro_arbitrage.toml
# ğŸ”Œ Connecting to WebSocket: wss://eth-mainnet...
# âœ… Connected to network 1 at block 18950123
# ğŸ­ Initializing Micro Arbitrage Manager...
# âœ… Micro Arbitrage Manager ready
# ğŸ¤– Starting automated arbitrage bot...
# ğŸ”„ Starting execution loop with 1000ms interval
# âœ… Bot is running. Press Ctrl+C to stop.
```

#### í…ŒìŠ¤íŠ¸ ëª¨ë“œ (ê¸°íšŒ ìŠ¤ìº”ë§Œ)

```bash
# Scan ëª¨ë“œ: ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒë§Œ íƒìƒ‰
MICRO_ARBITRAGE_MODE=scan cargo run --release --bin micro_arbitrage_bot

# Analyze ëª¨ë“œ: ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±
MICRO_ARBITRAGE_MODE=analyze cargo run --release --bin micro_arbitrage_bot

# Test ëª¨ë“œ: ì‹œìŠ¤í…œ ê²€ì¦
MICRO_ARBITRAGE_MODE=test cargo run --release --bin micro_arbitrage_bot
```

---

## ğŸš„ ì„±ëŠ¥ ìµœì í™”

### 1ï¸âƒ£ ê°€ìŠ¤ ë¹„ìš© ìµœì í™”

**ë™ì  ê°€ìŠ¤ ê°€ê²© ì „ëµ**:

```rust
/// ê²½ìŸ/ìˆ˜ìµì„± ê¸°ë°˜ ê°€ìŠ¤ ê°€ê²© ì¡°ì •
pub async fn calculate_optimized_gas_price(&self, opportunity: &MicroArbitrageOpportunity) -> Result<(U256, U256)> {
    // 1. í˜„ì¬ ê°€ìŠ¤ ê°€ê²© ì¡°íšŒ
    let (base_fee, priority_fee) = self.provider.get_gas_price().await?;
    
    // 2. ìˆ˜ìµì„± ê¸°ë°˜ ê°€ìŠ¤ ê°€ê²© ì¡°ì •
    let profit_ratio = opportunity.expected_profit.to_f64().unwrap_or(0.0) / 1000.0; // $1000 ê¸°ì¤€
    let gas_multiplier = (1.0 + profit_ratio * 0.5).clamp(1.0, 3.0);
    
    // 3. ê²½ìŸ ìˆ˜ì¤€ ê³ ë ¤
    let competition_level = self.analyze_competition_level().await?;
    let competition_multiplier = match competition_level {
        CompetitionLevel::Low => 1.0,
        CompetitionLevel::Medium => 1.2,
        CompetitionLevel::High => 1.5,
        CompetitionLevel::Critical => 2.0,
    };
    
    // 4. ìµœì¢… ê°€ìŠ¤ ê°€ê²© ê³„ì‚°
    let adjusted_priority = priority_fee * U256::from((gas_multiplier * competition_multiplier * 1000.0) as u64) / U256::from(1000);
    let max_fee = base_fee + adjusted_priority * U256::from(2);
    
    Ok((max_fee, adjusted_priority))
}
```

---

### 2ï¸âƒ£ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

**WebSocket ì—°ê²° ìµœì í™”**:

```rust
pub struct OptimizedPriceMonitor {
    connections: Arc<RwLock<HashMap<String, WebSocketConnection>>>,
    connection_pool: Arc<Mutex<Vec<WebSocketConnection>>>,
    reconnect_strategy: ReconnectStrategy,
}

impl OptimizedPriceMonitor {
    /// ì—°ê²° í’€ ê´€ë¦¬
    async fn manage_connection_pool(&self) {
        let mut interval = tokio::time::interval(Duration::from_secs(30));
        
        loop {
            interval.tick().await;
            
            // ë¹„í™œì„± ì—°ê²° ì •ë¦¬
            self.cleanup_inactive_connections().await;
            
            // ì—°ê²° í’€ í¬ê¸° ì¡°ì •
            self.adjust_pool_size().await;
        }
    }
}
```

---

### 3ï¸âƒ£ ë©”ëª¨ë¦¬ ìµœì í™”

**ë°ì´í„° ìºì‹± ì „ëµ**:

```rust
pub struct OptimizedCache {
    price_cache: Arc<RwLock<LruCache<String, PriceData>>>,
    opportunity_cache: Arc<RwLock<LruCache<String, MicroArbitrageOpportunity>>>,
    max_cache_size: usize,
}

impl OptimizedCache {
    /// ìºì‹œ í¬ê¸° ë™ì  ì¡°ì •
    async fn adjust_cache_size(&self) {
        let memory_usage = self.get_memory_usage().await;
        let max_memory = self.config.max_memory_mb * 1024 * 1024;
        
        if memory_usage > max_memory * 0.8 {
            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ 80% ì´ˆê³¼ ì‹œ ìºì‹œ í¬ê¸° ì¶•ì†Œ
            self.reduce_cache_size().await;
        } else if memory_usage < max_memory * 0.5 {
            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ 50% ë¯¸ë§Œ ì‹œ ìºì‹œ í¬ê¸° í™•ëŒ€
            self.increase_cache_size().await;
        }
    }
}
```

---

## ğŸ› íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ë¬¸ì œ 1: "Exchange connection failed"

**ì¦ìƒ**:
```
âŒ Failed to connect to Binance: connection timeout
```

**í•´ê²°ì±…**:
1. Binance API í‚¤ í™•ì¸
2. ë„¤íŠ¸ì›Œí¬ ë°©í™”ë²½ ì„¤ì • í™•ì¸
3. API Rate Limit í™•ì¸

```bash
# Binance API ì—°ê²° í…ŒìŠ¤íŠ¸
curl -H "X-MBX-APIKEY: $BINANCE_API_KEY" \
  "https://api.binance.com/api/v3/ping"
```

---

### ë¬¸ì œ 2: "No arbitrage opportunities found"

**ì¦ìƒ**:
```
ğŸ” ì•„ë¹„íŠ¸ë¦¬ì§€ ê¸°íšŒ ë°œê²¬: 0 ê°œ
```

**ì›ì¸**:
- ê°€ê²© ì°¨ì´ê°€ ì„ê³„ê°’ ë¯¸ë§Œ
- ìµœì†Œ ìˆ˜ìµì„± ì„ê³„ê°’ì´ ë„ˆë¬´ ë†’ìŒ
- ê±°ë˜ì†Œ ì—°ê²° ì‹¤íŒ¨

**í•´ê²°ì±…**:
```bash
# ìµœì†Œ ìˆ˜ìµì„± ì„ê³„ê°’ ë‚®ì¶”ê¸°
MIN_PROFIT_USD=1.0  # $1.0ë¡œ ì¡°ì •

# scan ëª¨ë“œë¡œ í˜„ì¬ ì‹œì¥ ìƒíƒœ í™•ì¸
MICRO_ARBITRAGE_MODE=scan cargo run --release --bin micro_arbitrage_bot
```

---

### ë¬¸ì œ 3: "Insufficient wallet balance"

**ì¦ìƒ**:
```
âŒ Insufficient wallet balance for arbitrage
```

**ì›ì¸**:
- ì§€ê°‘ ì”ê³  ë¶€ì¡±
- Flashloan ëª¨ë“œ ë¯¸ì„¤ì •

**í•´ê²°ì±…**:
```bash
# Flashloan ëª¨ë“œë¡œ ê°•ì œ ì „í™˜ (ì´ˆê¸° ìë³¸ 0 í•„ìš”)
FUNDING_MODE=flashloan

# ì§€ê°‘ ì”ê³  í™•ì¸
cast balance 0xYOUR_ADDRESS --rpc-url $HTTP_URL
```

---

### ë¬¸ì œ 4: "Exchange API rate limit exceeded"

**ì¦ìƒ**:
```
âŒ Rate limit exceeded for Binance API
```

**ì›ì¸**:
- API í˜¸ì¶œ ë¹ˆë„ ì´ˆê³¼
- API í‚¤ ê¶Œí•œ ë¶€ì¡±

**í•´ê²°ì±…**:
```bash
# API í˜¸ì¶œ ê°„ê²© ì¦ê°€
SCAN_INTERVAL_MS=2000  # 1ì´ˆ â†’ 2ì´ˆë¡œ ì¡°ì •

# API í‚¤ ê¶Œí•œ í™•ì¸
curl -H "X-MBX-APIKEY: $BINANCE_API_KEY" \
  "https://api.binance.com/api/v3/account"
```

---

## ğŸ“š ì°¸ê³  ìë£Œ

### ê³µì‹ ë¬¸ì„œ
- [Binance API Documentation](https://binance-docs.github.io/apidocs/spot/en/)
- [Coinbase Pro API](https://docs.pro.coinbase.com/)
- [Uniswap V2 Documentation](https://docs.uniswap.org/protocol/V2/introduction)
- [Aave V3 Flash Loans](https://docs.aave.com/developers/guides/flash-loans)

### ê´€ë ¨ íŒŒì¼
- `src/strategies/micro_arbitrage/` (ë§ˆì´í¬ë¡œì•„ë¹„íŠ¸ë¦¬ì§€ ì „ëµ)
- `src/strategies/micro_arbitrage/manager.rs` (í†µí•© ê´€ë¦¬ì)
- `src/strategies/micro_arbitrage/price_monitor.rs` (ê°€ê²© ëª¨ë‹ˆí„°)
- `src/strategies/micro_arbitrage/execution_engine.rs` (ì‹¤í–‰ ì—”ì§„)
- `src/bin/micro_arbitrage_bot.rs` (ì‹¤í–‰ ë°”ì´ë„ˆë¦¬)

---

## ğŸ“ FAQ

**Q1: ì´ˆê¸° ìë³¸ê¸ˆì´ ì—†ì–´ë„ ì•„ë¹„íŠ¸ë¦¬ì§€ ë´‡ì„ ìš´ì˜í•  ìˆ˜ ìˆë‚˜ìš”?**

A: ë„¤, `FUNDING_MODE=flashloan`ìœ¼ë¡œ ì„¤ì •í•˜ë©´ Aave Flash Loanì„ í†µí•´ **ì´ˆê¸° ìë³¸ê¸ˆ 0 ETH**ë¡œ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨, 0.09% ìˆ˜ìˆ˜ë£Œê°€ ë°œìƒí•©ë‹ˆë‹¤.

---

**Q2: Liquidation ì „ëµê³¼ ë¹„êµí–ˆì„ ë•Œ ì–´ë–¤ ì¥ì ì´ ìˆë‚˜ìš”?**

A:
- **ë¹ˆë„**: ì•„ë¹„íŠ¸ë¦¬ì§€ëŠ” ë” ìì£¼ ë°œìƒ (1ì´ˆë§ˆë‹¤ ìŠ¤ìº”)
- **ìˆ˜ìµ**: ì‘ì§€ë§Œ ì•ˆì •ì ì¸ ìˆ˜ìµ (0.1~2%)
- **ê²½ìŸ**: ë” ë§ì€ ë´‡ë“¤ê³¼ ê²½ìŸ
- **ë³µì¡ë„**: ìƒëŒ€ì ìœ¼ë¡œ ë‹¨ìˆœí•œ ë¡œì§

---

**Q3: ì–´ë–¤ ê±°ë˜ì†Œê°€ ê°€ì¥ ìˆ˜ìµì„±ì´ ë†’ë‚˜ìš”?**

A:
1. **Binance**: ê°€ì¥ ë§ì€ ê±°ë˜ëŸ‰, ë¹ ë¥¸ API
2. **Coinbase**: ì•ˆì •ì ì¸ ê°€ê²©, ë†’ì€ ì‹ ë¢°ë„
3. **Uniswap V3**: ê°€ì¥ íš¨ìœ¨ì ì¸ DEX
4. **SushiSwap**: ì¶”ê°€ ìˆ˜ìµ ê¸°íšŒ

---

**Q4: ê°€ìŠ¤ ë¹„ìš©ì„ ì¤„ì´ëŠ” ë°©ë²•ì€?**

A:
1. **Flashloan ì‚¬ìš©**: ì´ˆê¸° ìë³¸ 0ìœ¼ë¡œ ì‹œì‘
2. **ê°€ìŠ¤ ê°€ê²© ìµœì í™”**: ê²½ìŸ ìˆ˜ì¤€ì— ë”°ë¥¸ ë™ì  ì¡°ì •
3. **ë°°ì¹˜ ì²˜ë¦¬**: ì—¬ëŸ¬ ê¸°íšŒë¥¼ í•œ ë²ˆì— ì‹¤í–‰
4. **Layer 2 ì‚¬ìš©**: Polygon, Arbitrum ë“±

---

**Q5: Mainnetì—ì„œ ë°”ë¡œ ì‹¤í–‰í•´ë„ ì•ˆì „í•œê°€ìš”?**

A: **ì•„ë‹ˆì˜¤**, ë‹¤ìŒ ìˆœì„œë¡œ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”:
1. **Testnet (Goerli/Sepolia)**: ì „ì²´ í”Œë¡œìš° ê²€ì¦
2. **Mainnet Simulation**: `MICRO_ARBITRAGE_MODE=test` ì‹¤í–‰
3. **ì†Œì•¡ ìš´ì˜**: `MIN_PROFIT_USD=1.0` ì„¤ì •
4. **ì ì§„ì  í™•ëŒ€**: ì„±ê³µë¥  80% ì´ìƒ ë‹¬ì„± í›„ ë³¸ê²© ìš´ì˜

---

## ğŸ“Œ ë‹¤ìŒ ë‹¨ê³„

1. âœ… **Micro Arbitrage ì „ëµ ì´í•´ ì™„ë£Œ**
2. ğŸ”œ **ì‹¤ì „ ë°°í¬**: Testnet â†’ Mainnet ì „í™˜
3. ğŸ”œ **ìˆ˜ìµ ëª¨ë‹ˆí„°ë§**: Grafana/Prometheus ëŒ€ì‹œë³´ë“œ êµ¬ì¶•
4. ğŸ”œ **ê³ ê¸‰ ì „ëµ**: ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ê°€ê²© ì˜ˆì¸¡

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-01-06
**êµ¬í˜„ ì™„ì„±ë„**: 95% (Production Ready - v2.0)
**ì¶”ì²œ ì‹œì‘ ìˆœì„œ**: 2ìœ„ (ì•ˆì •ì ì¸ ìˆ˜ìµ ì „ëµ)